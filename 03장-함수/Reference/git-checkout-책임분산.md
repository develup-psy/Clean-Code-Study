### Git의 `switch` 명령어: 책임 분산을 위한 변화

기존 `checkout` 명령어는 Git에서 매우 강력한 기능을 제공했지만, **너무 많은 역할을 수행**하는 문제를 가지고 있었습니다. `checkout`은 다음과 같은 여러 기능을 담당했습니다.

1. **브랜치 변경:** `git checkout branch-name` → 특정 브랜치로 이동
2. **새 브랜치 생성 및 이동:** `git checkout -b new-branch` → 새로운 브랜치를 만들고 이동
3. **파일 복원:** `git checkout -- file.txt` → 특정 파일을 이전 커밋 상태로 되돌림
4. **Detached HEAD 모드 진입:** `git checkout commit-hash` → 특정 커밋을 checkout하여 분기 없이 작업

이처럼 `checkout`은 **브랜치 전환과 파일 복원이라는 서로 다른 개념을 하나의 명령어로 처리**하면서 혼란을 야기했습니다.  
사용자 입장에서는 `checkout`이 **현재 작업 브랜치를 변경하는 것인지, 특정 파일을 복원하는 것인지 혼동**할 가능성이 높았으며, **실수로 원치 않는 동작을 수행하는 경우도 많았습니다.**

#### 🛠 Git 2.23에서 `switch`와 `restore`로 분리

이러한 문제를 해결하기 위해 **Git 2.23(2019년 출시)**부터 `checkout`의 기능을 두 개의 명령어로 분리했습니다.

1. `git switch` → **브랜치 관련 작업만 담당**

   - 기존 `checkout`의 **브랜치 변경 및 생성 기능**을 전담
   - 예:
     ```bash
     git switch branch-name    # 브랜치 변경
     git switch -c new-branch  # 새 브랜치 생성 후 이동
     ```
   - 기존 `checkout`과 달리 **새 브랜치를 만들 때 `-b` 대신 `-c` 옵션을 사용**, 더 직관적인 명령 구조 제공

2. `git restore` → **파일 복원 전담**

   - 기존 `checkout`의 **파일 되돌리기 기능**을 따로 분리
   - 예:
     ```bash
     git restore file.txt      # 특정 파일을 마지막 커밋 상태로 복원
     git restore --staged file.txt  # staging 영역에서 특정 파일 제거 (add 취소)
     ```
   - 명확한 의도를 가진 명령어로 변경됨으로써 **혼동을 줄이고 실수를 방지**

#### 🏗 `switch`와 `restore` 도입의 의미

이러한 변화는 **소프트웨어 설계에서 중요한 "책임 분산(Separation of Concerns)" 원칙을 적용한 사례**입니다.  
Git 내부에서도 **각 기능의 역할을 명확히 구분함으로써** 사용자 경험(UX)을 개선하고, **더 직관적인 사용법을 제공**하는 방향으로 발전한 것입니다.

이는 클린 코드의 원칙과도 연결됩니다.  
하나의 함수나 객체가 너무 많은 역할을 맡으면 코드가 복잡해지고, 실수를 유발하며, 유지보수가 어려워집니다.  
Git의 `switch`와 `restore` 도입 사례처럼, **불필요한 책임을 줄이고 역할을 명확히 분리하는 것**이 개발 과정에서 중요한 원칙임을 보여줍니다.

> **💡 정리:**
>
> - 기존 `checkout` 명령어는 **너무 많은 기능(브랜치 전환, 파일 복원 등)을 수행**하여 혼란을 유발
> - Git 2.23부터 `switch`(브랜치 관련)와 `restore`(파일 복원)로 분리하여 **책임을 명확히 분산**
> - 이 과정은 소프트웨어 설계 원칙 중 **Separation of Concerns(책임 분리)**을 실천한 사례
> - 클린 코드에서도 **하나의 함수/객체가 하나의 역할만 담당해야** 유지보수성과 가독성이 향상됨
