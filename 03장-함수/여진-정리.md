# Chapter 3. 함수

<br>

## 📚 서론 

- 함수는 프로그램의 **기본 단위**이므로 **설계 품질에 직접적인 영향을 준다.**
- 함수는 코드의 기본 단위이며, 좋은 함수는 **가독성이 뛰어나고, 유지보수가 쉽고, 명확한 역할을 수행해야 한다.**
- 이 장에서는 **함수를 어떻게 작성해야 하는지에 대한 원칙과 기법**을 자세히 설명한다.

<br>

## 🔍 1. 함수의 본질과 코드 품질 

### 🤔 1) 함수란 무엇인가? 

- **함수의 개념과 역할**  
    함수는 프로그램을 구성하는 기본 단위로, 특정한 작업을 수행하는 코드 블록이다.  
    함수를 사용하면 **코드를 모듈화하여 재사용성을 높이고, 프로그램을 논리적으로 구조화**할 수 있다.  
    함수는 단순히 코드 조각이 아니라, **프로그램의 흐름을 제어하고, 데이터를 처리하는 핵심적인 역할**을 한다.

- **좋은 함수가 가지는 특징** 
    좋은 함수는 다음과 같은 특징을 가져야 한다.
    - **Simple (단순성)**  
        - 하나의 함수는 **하나의 역할**만 수행해야 한다.  
        - 함수가 단순할수록 **이해하기 쉽고 유지보수가 용이**하다.
    - **Readable (가독성)**  
        - 함수는 **자연스럽게 읽혀야 하며**, 다른 사람이 쉽게 이해할 수 있어야 한다.  
        - 코드의 흐름을 명확하게 표현하는 **서술적인 함수명**을 사용해야 한다.
    - **Maintainable (유지보수성)**  
        - 코드 변경 시, 영향을 최소화할 수 있도록 **독립적인 구조**를 가져야 한다.  
        - **중복을 최소화**하고, 재사용이 가능하도록 구성해야 한다.

### 📈 2) 함수가 코드 품질에 미치는 영향 

- **함수가 코드의 가독성과 유지보수성에 미치는 영향**  
    좋은 함수는 코드의 **가독성과 유지보수성을 향상**시킨다.  
    - **가독성 향상**  
        - 함수를 적절하게 분리하고 서술적인 이름을 사용하면, **코드를 읽는 사람이 이해하기 쉬워진다**.  
        - 함수의 역할이 명확해지므로, **주석 없이도 코드의 동작을 예측할 수 있다**.  
    - **유지보수성 증가**  
        - 작은 함수로 구성하면, 특정 기능을 변경할 때 **전체 코드에 미치는 영향을 최소화**할 수 있다.  
        - **코드 중복을 줄이고, 재사용성을 높이는 구조**를 만들 수 있다.

- **작은 함수가 중요한 이유** 
    함수는 가능한 한 **짧고 단순하게 유지**해야 한다.  
    - **짧은 함수는 이해하기 쉽다**  
        - 길고 복잡한 함수는 한눈에 이해하기 어렵다.  
        - 짧은 함수는 **논리적인 흐름을 명확하게 전달**할 수 있다.
    - **작은 함수는 테스트하기 쉽다**  
        - 한 가지 작업만 수행하는 함수는 단위 테스트(Unit Test)를 작성하기 쉽다.  
        - 작은 함수는 특정 기능을 독립적으로 검증할 수 있어 **디버깅과 유지보수가 용이**하다.
    - **하나의 역할만 수행하는 함수는 재사용 가능성이 높다**  
        - 다양한 곳에서 재사용할 수 있도록, **하나의 함수가 하나의 역할만 수행**해야 한다.  
        - 특정 기능을 변경해야 할 때, 함수 하나만 수정하면 되므로 **코드 수정이 용이하다**.

<br>

## 📏 2. 좋은 함수 작성 원칙 

### 🪶 1) 작게 만들어라 

- **함수의 크기를 줄이는 이유**  
    - **짧은 함수일수록 이해하기 쉽다**  
        - 긴 함수는 한눈에 파악하기 어려워 유지보수가 어렵다.  
        - 함수가 짧으면 **한 가지 역할을 명확히 수행하는지 확인하기 쉽다**.  
    - **함수는 20줄을 넘지 않도록 유지하는 것이 이상적이다**  
        - 짧은 함수는 **논리적인 구조를 유지하면서도 가독성을 높일 수 있다**.  
        - 긴 함수는 여러 개의 작업을 수행할 가능성이 높다 → **여러 개의 작은 함수로 분리해야 한다**.

- **블록과 들여쓰기의 영향**  
    - `if`, `else`, `while`, `switch` 등의 **블록을 한 줄로 유지하는 것이 바람직하다**.  
    - **들여쓰기 깊이가 깊어질수록 함수가 너무 크다는 신호다.**  
        - 들여쓰기가 많으면 **가독성이 떨어지고, 코드의 논리 흐름이 복잡해진다**.  
        - **들여쓰기 깊이는 1~2단계를 넘지 않도록 유지해야 한다**.

- **함수 내부에서 작은 함수를 호출하는 기법**  
    - **작은 함수를 만들고, 내부에서 이를 조합하여 더 큰 기능을 구현**하는 방식이 가독성과 유지보수성을 높인다.  
    - 한 가지 작업을 수행하는 작은 함수들을 조합하면 **코드의 모듈화가 가능**해지고, **코드를 재사용할 가능성이 증가**한다.

### 🔄 2) 한 가지 작업만 수행하라 

- **TO 문단 원칙과 함수의 단일 책임**  
    - 함수는 **"한 가지" 작업만 수행해야 한다**.  
    - 여러 개의 작업을 수행하는 함수는 **유지보수가 어렵고, 코드의 재사용성이 낮아진다**.  
    - 함수를 분석할 때, **"이 함수가 하는 일이 무엇인가?"** 라고 질문했을 때 **두 개 이상의 답이 나오면 리팩토링이 필요하다**.

- **함수 내부를 논리적 섹션으로 구분하는 방법**  
    - 함수가 여러 개의 작업을 수행한다면 **그 작업들을 하나의 개념으로 묶을 수 있는지 확인해야 한다**.  
    - 묶을 수 없다면, **함수가 너무 많은 역할을 하고 있는 것**이므로 분리해야 한다.

### 🧠 3) 함수의 추상화 수준 유지 

- **추상화 수준이 일정해야 하는 이유**  
    - **함수 내 모든 문장은 동일한 추상화 수준을 유지해야 한다.**  
    - 한 함수 내에 **고수준(개념적) 코드와 저수준(구현 세부사항) 코드가 섞이면 가독성이 떨어진다**.
    
| **추상화 수준**               | **설명**              | **예제 코드**                                               |
| ------------------------ | ------------------- | ------------------------------------------------------- |
| **고수준<br> (High-level)** | 개념적으로 큰 기능을 수행하는 코드 | `String getHtml(Page page) { return buildPage(page); }` |
| **중간수준 <br>(Mid-level)** | 특정 기능을 수행하는 코드      | `String pagePathName = PathParser.render(pagepath);`    |
| **저수준 <br>(Low-level)**  | 데이터를 조작하는 세부 구현 코드  | `.append("\n")`, `buffer.append("<html>");`             |

- **코드의 흐름이 이야기처럼 읽혀야 하는 원칙**  
    - 코드는 **위에서 아래로 자연스럽게 읽혀야 한다**.  
    - 한 함수 다음에는 **한 단계 낮은 추상화 수준의 함수**가 와야 한다.

### ⚙️ 4) 조건문과 제어 흐름 최적화  

- **switch 문과 if/else 문의 문제점** 
	- **switch 문은 한 가지 작업만 수행하기 어렵다.** 
	- 새로운 항목이 추가될 때마다 **코드를 변경해야 하므로 유지보수가 어렵다**.
	- OCP(개방-폐쇄 원칙)와 SRP(단일 책임 원칙)를 위반할 가능성이 높다. 

- **다형성을 활용한 switch 문 제거 기법** 
	- 다형성을 사용하면 **switch 문을 한 곳에만 존재하도록 숨길 수 있다**. 
	- switch 문을 팩토리 패턴과 같은 **객체 지향적인 설계로 대체**하면 코드의 유연성이 증가한다.

- **개방-폐쇄 원칙(OCP)과 단일 책임 원칙(SRP) 적용** 
	- OCP: **기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다**. 
	- SRP: **한 함수는 한 가지 책임만 가져야 한다**. 

### 📝 5) 서술적인 이름을 사용하라  

- **가독성을 높이는 함수명 선택법** 
	- 함수명을 통해 **코드의 역할이 명확하게 전달**되어야 한다. 
	- 짧고 의미 없는 이름보다 **긴 서술적인 이름이 가독성 측면에서 더 낫다**.

- **‘길고 서술적인 이름이 짧고 애매한 이름보다 낫다’ 원칙** 
	- `calculate()` → ❌ 너무 모호한 이름 
	- `calculateTotalPrice()` → ✅ 더 구체적인 이름

- **네이밍 일관성을 유지하는 방법** 
	- 동일한 역할을 하는 함수는 **일관된 명명 규칙을 따라야 한다**. 
	- 예: `fetchUser()`, `fetchOrder()` (✔) `getUser()`, `retrieveOrder()` (❌ 일관성 부족) 

### 🧳 6) 함수의 인수 최적화  

- **함수 인수는 몇 개까지가 적절한가?** 
	- **0개(무항) 또는 1개(단항)가 가장 이상적이다**. 
	- **2개(이항)까지는 가능하지만, 3개(삼항) 이상은 피하는 것이 좋다**. 
	- 4개 이상의 인수를 사용해야 한다면, **인수 객체를 만들어야 한다**. 

| 인수 개수 | 적절성 | 설명 |
| --- | --- | --- |
| **0개 (무항 함수)** | ✅ 최적 | 입력이 없으면 함수 호출이 가장 간단해짐 | 
| **1개 (단항 함수)** | ✅ 좋음 | 하나의 입력값을 받아 변환하거나 검사하는 함수 | 
| **2개 (이항 함수)** | ⚠️ 가능하면 피할 것 | 두 개의 인수는 이해하기 어렵고, 순서를 혼동할 위험이 있음 | 
| **3개 (삼항 함수)** | 🚨 피해야 함 | 세 개의 인수가 필요하면, 코드 가독성이 급격히 떨어짐 | 
| **4개 이상 (다항 함수)** | ❌ 절대 피해야 함 | 유지보수가 어렵고, 테스트 케이스 조합이 기하급수적으로 증가 | 

- **인수 최적화를 해야 하는 이유** 
	- **가독성 향상** 
		- 인수가 많으면 함수 호출부에서 **각 인수가 무엇을 의미하는지 이해하기 어렵다**. 
		- `processData(true, 10, "user")` → ❌ 의미를 파악하기 어려움 
		- `processData(shouldValidate, maxRetries, userType)` → ✅ 의미 전달이 명확함 
	- **순서 오류 방지** 
		- 같은 타입의 인수가 여러 개 존재할 경우, **순서를 실수로 바꿔 전달할 가능성이 높아진다**. 
		- `assertEquals(expected, actual)` → **순서를 실수하는 경우가 많음** 
	- **유지보수성 향상** 
		- 인수가 많으면 **새로운 기능 추가 시 함수 변경이 필요해지는 경우가 많다**. 
		- **인수 객체를 사용하면 기존 함수의 구조를 변경하지 않고도 확장이 가능하다**. 

- **단항, 이항, 삼항 함수의 차이와 단항 함수의 장점** 
	- **단항 함수** (`doSomething(data)`) 
		- 가장 이상적인 형태이며, 가독성이 높다. 
	- **이항 함수** (`calculateTotal(price, tax)`) 
		- 경우에 따라 유용하지만, 두 개의 인수를 항상 신경 써야 한다. 
	- **삼항 함수 이상 (`compare(a, b, c)`)** 
		- 세 개 이상의 인수가 필요한 경우, **인수 객체를 활용하여 명확성을 높여야 한다**.

<br>

## 🔧 3. 안정성과 유지보수를 위한 함수 설계 

### 🚫 1) 부수 효과(Side Effect)를 최소화하라 

- **부수 효과란?**  
    - 함수가 본래의 의도된 동작(입력값을 처리하고 결과를 반환하는 것) 외에 **숨겨진 상태 변경이나 예기치 않은 동작을 수행하는 것**을 의미한다.  
    - 예) **전역 변수 변경, 객체 상태 변경, 파일 시스템 조작, 네트워크 요청 등**

- **부수 효과가 문제인 이유**  
    1. **코드의 예측 가능성이 낮아짐**  
        - 함수가 기대한 대로 동작하는지 확신할 수 없음.
    2. **디버깅과 유지보수가 어려워짐**  
        - 함수 호출에 따라 예상치 못한 값 변경이 발생하여 버그 발생 가능성 증가.
    3. **테스트가 어려워짐**  
        - 외부 상태를 변경하는 함수는 **독립적인 단위 테스트(Unit Test)가 어렵다.**
        - 테스트마다 동일한 입력을 주더라도 실행 환경에 따라 결과가 달라질 수 있음.

- **해결 방법: 함수의 순수성(Pure Function) 유지**  
    - 순수 함수(Pure Function):  
        - 같은 입력에 대해 항상 같은 출력을 반환하고, **외부 상태를 변경하지 않는 함수**.  
    - **순수 함수의 장점**:  
        - **예측 가능성 증가** → 입력값만 신경 쓰면 됨.  
        - **디버깅과 테스트 용이** → 독립적인 단위 테스트 가능.  
        - **코드 재사용성이 높아짐** → 부수 효과가 없으므로 다른 코드에서도 안전하게 활용 가능.

### 🛠️ 2) 명령(Command)과 조회(Query)를 분리하라 

> "함수는 무언가를 수행하거나, 무언가를 반환하는 두 가지 역할 중 하나만 해야 한다."

- **명령-조회 혼합의 문제**  
    - 함수 호출자가 **이 함수가 삭제만 하는지, 조회도 하는지 명확히 알기 어려움**.

- **해결 방법: 명령과 조회 분리**  
    - 명령(Command): **객체 상태를 변경**하는 함수 (예: `deleteUser()` → 삭제만 수행)  
    - 조회(Query): **객체 상태를 조회**하는 함수 (예: `isUserExists()` → 삭제 여부 확인)

### 🚨 3) 오류 코드보다 예외(Exception)를 사용하라 

- **오류 코드 반환 방식의 문제점**  
    - 전통적으로 많은 함수들은 오류 발생 시 **오류 코드를 반환**하는 방식을 사용했음.  
    - 하지만 이는 **코드 가독성을 떨어뜨리고, 예외 처리를 누락할 가능성을 높임**.

- **해결 방법: 예외(Exception) 활용**  
    - **예외를 사용하면 오류 처리 코드가 분리되어 가독성이 향상됨**.  
    - **새로운 오류가 추가되더라도 기존 코드를 수정하지 않아도 됨 (OCP 원칙 준수)**.

### 🔁 4) 코드 중복을 피하라 

- **중복 코드가 초래하는 문제**  
    - **중복된 코드가 많을수록** 버그 발생 가능성이 높아지고, 수정할 때 여러 곳을 변경해야 하므로 유지보수가 어려워짐.

- **해결 방법: 중복 제거를 위한 리팩토링**  
    - **1) 함수 추출(Extract Method)**  
        - **중복된 코드를 별도의 함수로 분리하여 재사용 가능하게 만듦.**

<br>

## 🏗️ 4. 함수 구현 방법론과 시스템 설계 원칙 

### 🧱 1) 구조적 프로그래밍과 함수 설계 

- **구조적 프로그래밍이란?**  
    - **Edsger Dijkstra**가 제안한 프로그래밍 패러다임으로, **코드의 논리적 구조를 명확히 하여 가독성과 유지보수성을 높이는 것**이 목표.

- **구조적 프로그래밍의 원칙**
	1. **함수는 단일 입·출력을 유지해야 한다.**
	    - 하나의 함수가 **여러 개의 exit(return) 문을 가지면 흐름을 파악하기 어려움**.
	    - 그러나 **함수가 작다면 예외적으로 조기 반환(early return)을 허용할 수도 있음**.
	2. **함수는 하나의 기능만 수행해야 한다.**
	    - 여러 가지 역할을 수행하는 함수는 **논리적 구조를 흐트러뜨리며 유지보수를 어렵게 만듦**.
	    - 이를 위해 **작은 함수로 분리하고, 명확한 네이밍을 적용**해야 함.
	3. **복잡한 조건문을 단순화해야 한다.**
	    - 중첩된 `if-else` 문은 가독성을 떨어뜨리므로, **논리를 분리하여 가독성을 높여야 함**.

### ✍️ 2) 함수 작성 프로세스 

> "좋은 함수는 처음부터 완벽할 필요가 없다. 처음엔 길고 복잡할 수 있지만, 리팩토링을 통해 개선하면 된다."

- **함수 작성 과정**  
    1. **초기 함수 작성 (First Draft)**  
	    - 처음에는 **길고 복잡한 형태**일 수 있다.
		- 코드의 흐름을 빠르게 구현한 후, 점진적으로 개선하는 과정이 필요하다.
    2. **함수 분리 (Extract Method)**  
		- 중복된 코드와 **여러 개의 기능을 수행하는 함수**를 작은 함수로 나눈다.
		- **하나의 함수는 하나의 역할만 수행하도록 수정**.
    1. **의미 있는 함수 이름 부여 (Rename Method)**  
	    - **함수 이름이 코드의 의도를 명확하게 전달하도록 개선**.
		- 길어도 상관없으니, **서술적인 네이밍을 사용**.
    1. **단위 테스트 작성 (Unit Test)**
	    - 함수가 **올바르게 동작하는지 검증**하기 위한 단위 테스트를 작성한다.
		- 리팩토링을 수행할 때 **기능이 깨지지 않도록 보호하는 역할**.

### 💡 3) 좋은 함수의 핵심 원칙 정리 

- **좋은 함수의 조건**  
    1. **짧고 명확해야 한다.**  
    2. **의미 있는 이름을 사용해야 한다.**  
    3. **한 가지 작업만 수행해야 한다.**  
    4. **중복을 제거해야 한다.**  
    5. **부수 효과를 최소화해야 한다.**  
    6. **명령과 조회를 분리해야 한다.**

### 🌐 4) 함수와 시스템의 관계 

- **함수는 시스템을 구성하는 기본 요소**  
    - 함수 설계가 **시스템 품질을 결정**한다.  
    - 함수 설계를 잘하면 **모듈화(Modularity)가 잘 된 구조를 만들 수 있다.**
