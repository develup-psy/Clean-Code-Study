# 3장. 함수

---

## 📍 REVIEW

모든 프로그래밍의 가장 기본적인 단위인 ‘함수’에 대해 이야기하는 장이다. ‘좋은 함수’란 어떤 것인지에 대한 이야기가 함수를 작성하는 다양한 방법과 함께 서술되고 있다. 장의 처음에 길고 복잡한 하나의 클래스 예시가 함수 작성 기법을 적용하며 변화해나가는 부분이 핵심으로 보인다. 결론적으로는 다시 원점으로 돌아가 유지보수성이다. 작은 단위로, 역할대로 분리되어 이해하기도 쉽고 관리하거나 확장하기에도 용이하며 스스로의 존재 의도가 명확히 표현되는 함수가 결국 ‘좋은 함수’이다. 모든 방법론은 이 원칙에 기인함을 인지하면 이 장에 대한 이해는 충분할 것이다.

## 📍 함수를 작성하는 방법

함수를 작성하는 것은 글을 작성하는 것과 같다. 한 번에 완벽한 글을 작성할 수 없는 것처럼, 한 번에 완벽한 함수를 작성할 수도 없다. 글은 초고를 작성한 뒤 문장을 다듬고 문단이 정리되는 여러 수정 작업을 통해 반복적인 퇴고를 거친 후에야 탈고된다. 프로그래밍 작성도 유사하게, 첫 작성에서는 여러 반복적인 실행문과 여러 일을 하는 함수, 뒤섞인 추상화 수준의 함수를 작성할 수 있다. 초안이 작성된 이후에, 아래 서술할 규칙에 따라 함수를 다듬고 클래스를 정리해나가면 되는 것이다.

## 📍 함수가 담아야 하는 이야기

### 🔍 한 가지 일을 하는 함수

각 함수는 하나의 이야기를 표현해야 한다. 이를 위한 필수 조건은 “작은 함수”이다. 긴 함수는 여러 이야기를 할 수 밖에 없다. 기능 단위로 분리하여 중복 없는, 짧은, 작은, 하나의 일만 하는 함수를 구성하도록 노력해야 한다.

#### ☑️ ’한 가지 일’의 기준 : 추상화 수준과 함수 섹션

‘한 가지’라는 기준에 대한 모호성이 생긴다.

이 때 기능 개수의 단위는 “추상화 수준”의 개수와 일치하다. 의미를 유지하면서 추상화 수준을 높이는 방법을 고민하는 것이 함수의 단위를 작게 하는 고민과 같을 것이다. 함수 내의 모든 작업에 대한 추상화 수준은 동일해야 하며, 그 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다. 즉, 추상화 수준을 고려하여 단계별로 하나씩 함수를 구성하는 것이 하나의 일을 하는 함수를 구성하는 방법이다.

또한, 한 가지 일을 하는 함수는 섹션이 구분되어 있지 않고 하나의 섹션으로 구성되어야 한다. 다중 섹션과 블록 구조의 제어문은 다르다. 블록 구조의 제어문은 어떻게 다루어야 할까?

#### ☑️ 블록구조의 함수 : 함수 호출로 구현

여러 블록이 생길 수밖에 없는 if-else문, switch-case문, do-while문, try-catch문 등의 경우, 여러 가지 일을 한다고 여겨질 수 있다. 이런 블록 구조에서는, 내부에 중첩 구조가 이루어지는 것을 지양해야 한다. 블록 내에서 여러 줄로 기능이 서술되기 보다 해당 기능이 작성된 적절한 이름의 함수를 호출하도록 해야 한다. 즉, 각 블록이 동일한 추상화 수준의 함수가 불러지는 구조이어야 한다.

또한 유의해야 하는 점은, 루프가 발생할 때,

#### ☑️ 명령과 조회가 분리된 함수

명령하는 기능과 조회하는 기능은 서로 구분되는 기능으로 취급해야 한다. 즉, 모든 함수는 객체 상태를 변경하거나, 객체 정보를 반환하거나의 하나의 기능만을 담아야 한다는 의미이다. 조회의 목적으로 함수를 호출했는데 기타 명령을 해야 한다거나 명령의 목적으로 함수를 호출했는데 조회만 되는 등의 예측 불가능한 상황이 있어서는 안된다는 것이다.

### 🔍 하나의 추상화 수준을 갖는 함수

함수 내 모든 문장의 추상화 수준이 동일해야만 함수는 한 가지 작업을 한다. 추상화 수준을 갖게 하는 방식의 핵심은 “근본 개념”과 “세부사항”을 분리하는 것이다. 근본 개념을 기준으로 수준을 맞춰갈 때, 함수는 하나의 이야기를 담을 수 있다. 다만 어려운 점은, 추상화 수준에 따라 함수를 분리하기가 쉽지 않다는 것이다.

#### ☑️ 추상화 수준 분리하기

책에서는 함수를 위에서 아래로 서술되는 ‘이야기’로 비유한다. 거기에 조금 더 살을 붙여, 나는 함수를 ‘트리 구조’의 이야기로 비유하고 싶다. 이야기는 선후관계가 있고, 서술되는 내용이 내려가는 단계가 있다. 프로그래밍을 이야기로 변환하면 TO 문단이 될 것인데, 이걸 트리 구조로 구상한다면 단계 별 추상화 수준이 보다 명확히 보일 것이다.

#### ☑️ 추상 팩토리를 통한 다형성 구현

하나의 추상화 수준을 갖는다는 건, 같은 수준의 인스턴스가 하나의 추상화로 묶일 수 있다는 것을 의미한다. 여러 인스턴스를 생성하는 경우 추상 팩토리를 구성하는 방법을 고민해보자.

추상 팩토리가 효율적으로 사용될 수 있는 예시는 switch 문이다. 각 case 별로 동일한 수준의 인스턴스를 생성하도록, switch 문을 추상 팩토리 클래스에 구현될 수 있을 것이다.

### 🔍 적은 인수를 갖는 함수

함수의 인수 개수는 적을 수록 좋다. 삼항보다는 이항, 이항보다는 단항, 단항보다는 무항이다.

#### ☑️ 많은 인수가 초래하는 문제점

- 함수 인수로 전달되는 순간, 근본 개념이 아닌 세부사항에 해당하는 인수에 대해 파악해야 한다. 함수를 읽는 관점에서, 함수를 호출할 때마다 인수에 대해 파악하는 데 소요될 시간을 생각해봐라. 적은 함수일 수록 추가적인 소요 시간이 적을 것이다.
- 테스트 관점에서, 많은 인수가 있을 경우 갖가지 유효한 조합을 구성하기가 까다롭다.
- 구현하는 관점에서, 입력할 인수의 선후 관계를 기억해야만 한다. 함수 인수가 많아질 수록, 어떤 것이 앞에 와야 하는 부분인지 파악하려면 매번 함수에 대해 찾아보는 추가적인 시간이 소요될 수밖에 없다.

#### ☑️ 단항 함수

대부분의 단항함수는 주로 아래 세 가지 경우에 해당한다.

1. 질문을 던지는 경우

   ⇒ boolean fileExists(”MyFile”) 처럼 인수에 대한 boolean 값을 반환하는 경우다.

2. 인수를 변환해 결과를 반환하는 경우

   ⇒ InputStream fileOpen(”MyFile”) 처럼 String 형의 파일 이름을 InputStream으로 변환하는 경우다.

3. 이벤트 : 입력 인수로 시스템 상태를 바꾸는 경우  
   ⇒ passwordAttemptFailedNtimes(int attempts) 처럼 비밀번호 입력 시도 횟수에 따라 시스템 내용이 변경되는 경우다.


위에 서술된 경우가 아니라면 단항 함수보다는 무항 함수를 작성하도록 해야 하며, 더 많은 인수가 들어가는 경우 위에 서술된 경우대로 다양한 단항 함수를 호출하는 방식으로 작성하도록 해야 할것이다.

#### ☑️ 이항 함수

이항 함수가 적절한 경우는 아래에 해당한다.

1. 인수 2개가 한 값을 표현할 때 (예: x, y)
2. 자연적인 순서가 있을 때  
   ⇒ assertEquals(expected, actual)은 자연적인 순서가 아니므로, 순서를 인위적으로 기억해야 하는 경우에 해당한다. 이런 경우, assertExpectedEqualsToActual 등으로 함수명을 바꾸는 것도 해결책이 될 수 있다.


이 외의 경우, 단항 함수로 바꾸도록 노력해야 한다.

#### ☑️ 기타 다항 함수

모든 경우에서, 인수의 수를 줄이려 노력해야 한다. 사실상 이항함수로 표현될 수 있는 경우라면 이항함수, 가능하다면 단항 또는 무항함수로 대체하는 편이 좋다.

예를 들어 인수가 가변적인 함수 String.format을 생각해보자. 이 경우, 선언부는 public String format(String format, Object… args)로 사실상 이항함수로 취급될 수 있다.

## 📍 함수가 주의해야 할 기능

### 🔍  부수 효과를 일으키지 말 것

함수가 수행하기로 한 기능 외의 부수적인 효과가 야기되는 것을 지양해야 한다. 부수적인 효과가 일어난다는 것은 곧 한가지 일을 하고 있지 않다는 것과 같은 의미이다.

특히 주의해야 하는 경우는 클래스 변수를 수정하거나, 인수, 시스템 전역 변수를 수정하는 등 함수명에서 예상되는 수행내용 외의 기능이 포함될 때이다. 꼭 부수적인 효과를 필히 포함해야 하는 경우, 함수 명에서 함께 명시해주는 것이 좋다. 함수를 선언하는 시점에서 함수의 수행 기능이 예측 가능하도록 말이다.

예를 들어, Session.initialize() 호출로 기존 세션의 내용을 초기화하는 것처럼 시스템의 정보를 건드리는 경우, 함수명에 AndInitializeSession 키워드 등을 포함하는 것이 좋다.

#### ☑️ 시간적인 결합과 순서 종속성

부수적인 효과는 시간적인 결합(temporal coupling) 또는 순서 종속성(order dependency)을 초래하기도 한다. 이는 시간이나 순서에 따른 의존성의 결합이 있다는 의미이다. 별도의 A, B 이벤트가 별개의 함수가 아닌 하나의 함수 안에 존재할 때 생기는 경우를 살펴보자.

- 시간적인 결합이란, 별개의 이벤트임에도 불구하고, 시간적으로 분리해 A만 또는 B만 발생하는 상황을 처리할 수 없고, A와 B가 일어나는 시간이 결합되어 처리할 수밖에 없다는 것을 의미한다.
- 순서 종속성이란, 두 이벤트가 적힌 함수가 A-B 의 순서로 작성되었다면, B-A 순서로 발생하는 상황을 처리할 수 없고, A와 B가 일어나는 순서를 종속되게 처리할 수밖에 없다는 것을 의미한다.

### 🔍  오류 코드가 아닌 예외를 사용할 것

오류 코드를 사용하는 방식은, 별도의 enum 클래스 등으로 오류 코드를 관리하고 있는 경우에 해당한다. 아래와 같은 이유로 오류 코드 관리 보다는 예외를 처리하는 것이 적절하다.

- 오류코드를 관리하는 클래스는 의존성 자석이다. 오류 코드 목록에 변경이 생기는 경우에는 클래스 전부를 다시 컴파일하고 다시 배치해야 한다. 예외로 처리하는 경우, 예외는 Exception 클래스에서 파생되기 때문에 재컴파일/재배치의 과정이 불필요하다.
- 오류코드 반환 시, 호출자는 오류 코드를 곧바로 처리해야 하며 명령과 조회가 분리되어야 한다는 규칙을 무시한다.

### 🔍 단일 입/출구 규칙을 따를 것

모든 함수, 그리고 함수 내 모든 블록은 하나의 입구와 하나의 출구가 존재해야 한다. 즉, 루프 내 goto는 절대로 사용되어서는 안됨을 의미한다. 때때로break나 continue는 단일 입/출구 규칙을 따르는 것보다 효과적일 수 있겠으나, goto는 최대한 사용을 지양하라고 저자는 강조한다. 함수가 아주 클 때야 효과가 있을 것이지만, 함수의 크기를 크게 하고 제어 조건을 거는 것 보다 작은 단위로 함수를 쪼개는 편이 구조적으로 함수를 조직할 수 있는 방안이다.