# Chapter 6. 객체와 자료 구조


- 객체지향 vs 절차적 설계 논쟁은 단순 스타일 차이가 아닌 **철학과 구조**의 차이
- 모든 것을 객체로 만드는 것이 **꼭 좋은 것은 아니다**
- 설계 판단 기준을 세우기 위해 아래 개념들을 분리 정리

---

## 🧑‍💻 1. 자료 추상화 

###  자료 구조 방식 vs 추상 인터페이스 방식

| 구분 | **구체적인 자료 구조 방식** | **추상적인 인터페이스 방식** |
| --- | --- | --- |
| **설명** | - 변수에 직접 접근하거나, 단순 get/set 함수로 노출<br>- 내부 구현(데이터 구조와 표현 방식)이 **외부에 드러남** | - 의미 있는 동작을 통해 접근<br>- 구현 세부는 숨기고, **개념적 의미를 중심으로 인터페이스 제공** |
| **추상화 수준** | 낮음 (구현 노출) | 높음 (구현 은닉) |
| **변경 유연성** | 구현 변경 시 외부 코드에 영향 발생 | 구현 변경이 외부에 영향을 주지 않음 |
| **클래스/인터페이스 설계 철학** | 구조체에 가까움(절차적 스타일) | 진정한 객체지향 설계 |
| **문제점** | - 캡슐화 위반<br>- 구조적 의존 증가<br>- 의미 없는 get/set 반복 | - 설계 부담이 있지만 더 유연하고 견고함 |

> get/set만 있다고 추상화된 것이 아님!
> 
> “어떻게 저장되는지” 보이면 자료 구조,  
> “무엇을 할 수 있는가”만 보이면 객체.

---

<br>

## 🛠️ 2. 객체 vs 자료 구조 

### 본질적 차이

| 구분 | **객체(Object)** | **자료 구조(Data Structure)** |
| --- | --- | --- |
| **공개하는 것** | 동작(함수, 메서드) | 데이터(변수 필드) |
| **숨기는 것** | 데이터 | 동작 |
| **외부에서 알 수 없는 것** | 내부 데이터 구조 | 동작이 어떤 방식으로 사용될지 |
| **특징** | - 캡슐화 지향<br>- 구현 숨김<br>- 다형성 활용 가능 | - 단순한 데이터 보관<br>- 구조 명확<br>- 처리 방식은 외부에 맡김 |

### 절차적 방식 vs 객체지향 방식의 비교

| 설계 요소 | 객체지향(절차적 코드) | 절차적 설계(객체지향 코드) |
| --- | --- | --- |
| 새로운 자료 구조 추가 | 쉬움 | 어려움 |
| 새로운 동작 추가 | 어려움 | 쉬움 |

> 객체와 자료 구조는 방향성이 정반대임  
> → 복잡도와 변화 양상에 따라 **전략적으로 선택**해야 함

---

<br>

## 🧐 3. 설계 선택 기준 

| 상황 | 적합한 설계 |
| --- | --- |
| 자료 타입이 자주 바뀜 | 객체지향 설계 |
| 기능이 자주 바뀜 | 절차적 설계 + 자료 구조 |
| 단순 전달/보관 목적 | 구조체 또는 DTO |

> “모든 것을 객체로 만들려는 습관은 위험하다.”

---

<br>

## 🚫 4. 디미터 법칙 (Law of Demeter) 

> “낯선 객체 말고, 친구 객체와만 놀아라”

- **모듈은 자신이 조작하는 객체의 내부 구조를 몰라야 한다**  
→ 즉, 객체는 **자신의 친구까지만 접근해야 하며 낯선 객체는 다루지 말라**
- 공식 정의 (클래스 C의 메서드 f는 다음 객체의 메서드만 호출 가능)
    1. 클래스 C 자체
    2. f가 생성한 객체
    3. f의 매개변수로 넘어온 객체
    4. C의 인스턴스 변수에 저장된 객체
- 디미터 법칙 위반 여부 판단 기준
    - 코드가 디미터 법칙을 **진짜 위반했는지는 상황에 따라 다름**
    - 즉, **객체인지 자료 구조인지에 따라 디미터 법칙 적용 여부가 달라짐**
- **바람직한 설계 방향**
    - 내부 구조가 노출되지 않도록, **동작을 통한 캡슐화** 필수
    - 외부에서는 **“무엇을 해야 하는가”만 알도록 구현**
    - **“무엇을 해야 하는가”만 말하고, “어떻게”는 객체에게 맡김**

> 디미터 법칙은 객체와 자료 구조의 구분에 따라 해석이 달라짐

---

<br>

## ⚙️ 5. 실전 구조 비교 

### DTO (Data Transfer Object)

- 목적: **계층 간 데이터 전달**
- 특징:
    - 공개 필드 or get/set
    - 의미 있는 동작 없음
    - **순수한 자료 구조**
- 사용처: DB ↔ API ↔ 애플리케이션 계층 등

### Active Record

- DTO + 저장/조회 함수 (`save()`, `find()` 등)
- **비즈니스 로직을 포함하면 잡종 구조가 됨**
- 바람직한 사용:
    - Active Record는 데이터 구조로만
    - **비즈니스 로직은 별도 객체로 분리**

---

<br>

## 🔚 6. 결론 요약 

| 항목 | **객체** | **자료 구조** |
| --- | --- | --- |
| 공개 | **동작(함수)** | **데이터(변수)** |
| 숨김 | 데이터 | 동작 없음 |
| 장점 | 기존 동작은 유지하면서 **새로운 자료형 추가가 쉬움** | 기존 자료형은 유지하면서 **새로운 동작 추가가 쉬움** |
| 단점 | 새로운 동작 추가가 어려움 | 새로운 자료 구조 추가가 어려움 |

> ✅ 좋은 개발자는 도구의 한계를 아는 사람  
> 객체와 자료 구조를 **목적에 따라 구분**해 사용하자


- 객체는 **"무엇을 할 수 있는가"를 드러내고**, 자료 구조는 **"무엇을 가지고 있는가"를 드러낸다**
- get/set 함수만 있는 클래스는 **진정한 캡슐화가 아님**
- 디미터 법칙은 객체 설계에서 **구조 은닉의 핵심 원칙**
- DTO, Active Record는 **자료 구조로만 활용**
- **설계는 맥락이 중요하다** – 상황에 맞는 전략 선택
