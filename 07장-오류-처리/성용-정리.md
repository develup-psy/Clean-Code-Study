# 7장 깨끗한 코드는 안정성도 높아야 한다.

## 1. 7장 핵심 요약

7장에서 저자는 오류 처리를 어떻게 하면 프로그램 전반의 논리 흐름을 훼손하지 않으면서도 안정적으로 구현할 수 있는지를 강조합니다.

프로그램은 언제든 입력이 이상하거나 디바이스가 실패할 수 있으므로 오류는 필연적으로 일어날 수밖에 없습니다.

하지만 잘못된 오류 처리 방식은 코드 가독성과 유지보수성을 망치기 쉽습니다. 따라서 오류 처리를 독자적인 문제로 다루고 주요 로직과 분리하여 안정성과 가독성을 동시에 달성하라는 것이 저자가 전하려는 핵심 메시지입니다.

## 2. 7장 내용 정리

### 하면 안되는 행동

1. 오류 코드를 반환하는 방식

- 오래된 언어에서는 예외를 지원하지 않아 오류 발생 시 ‘오류 플래그 설정’, ‘오류 코드 반환’ 등이 흔했습니다
- 하지만 이런 방식은 오류 처리가 주 로직과 섞여 코드가 장황해지고, 호출자마다 다르게 대응해야 하므로 복잡성을 높입니다.
- 예외를 던지는 편이, 논리 흐름에서 ‘정상 처리’와 ‘오류 처리’를 분리하므로 훨씬 깔끔하기에 웬만해선 오류 코드를 반환하기 보단 예외를 던지는 것을 권장한다 합니다.

2. null을 반환 / null을 인수로 전달

- 메서드가 null을 반환하면 호출자가 매번 null 체크를 해야 하고, “누군가는 한 번쯤 null 체크를 잊을” 수 있습니다.
- 그 결과 런타임 NPE(NullPointerException)가 발생해 프로그램이 통제 불능 상태가 될 수도 있습니다.
- 인수로 null을 전달하는 것도 마찬가지로 위험합니다. 메서드가 p1 != null 등을 일일이 체크하지 않으면 예외 발생 확률이 높아집니다.
- 결론은 애초에 null을 반환·인수로 전달하지 않는 정책이 좋다는 것입니다(‘Special Case 객체’나 ‘빈 객체’, 또는 예외 던지기로 대체)

### 저자가 권장하는 방법

1. TDD로 예외 범위를 정하라

- 저자는 TDD 방식을 통해 예외 처리를 구현해나가는 과정을 예시로 들고 있습니다.

  1. 테스트 코드부터 작성

  ```java
    @Test(expected = StorageException.class)
  public void retrieveSectionShouldThrowOnInvalidFilename() {
    sectionStory.retrieveSection("invalid-file");
  }
  ```

  - 유효하지 않은 파일명을 주면 StorageException이 발생해야 한다고 명시

  2. 실패 테스트를 통과시키기 위한 최소 구현

  - 처음엔 코드가 예외를 던지지 않아 테스트가 실패하므로, “파일이 없으면 예외를 던지도록” 로직을 작성한다.

  ```java
  public List<RecordedGrip> retrieveSection(String sectionName) {
    try {
        FileInputStream fis = new FileInputStream(sectionName);
    } catch (FileNotFoundException e) {
        throw new StorageException("Retrieval error", e);
    }
    return new ArrayList<>();
  }
  ```

  3. 테스트 통과 후 리팩터링

  - 이제 예외가 제대로 발생해 테스트가 통과하니, 가독성과 범위를 더 깔끔히 정리(예외 타입, 블록 범위 등)할 수게 된다.
  - TDD로 “언제 예외가 발생해야 하는지”를 미리 테스트로 정의하면, 필요한 최소 구현을 통해 예외 처리를 단단히 설계할 수게 됩니다.

2.  체크 예외보다 언체크 예외를 사용하라

- 체크 예외(Checked Exception)의 문제점은 OCP(Open-Closed Principle)를 위반한다는 점이라고 합니다
- 하위 함수가 새 체크 예외를 던지면 상위 함수 모든 곳에 throws나 catch를 추가해야 하고
- 이에 따라 수정 범위가 전반으로 확산” 되어 캡슐화가 깨집니다.
- 반면 언체크 예외는 RuntimeException 계열로, 호출부가 굳이 throws로 선언할 필요가 없게 되면서
- 코드 구조가 유연해지고, 하위 단계 변경이 상위 단계에 전파되지 않아 캡슐화가 유지됩니다.
- 따라서 큰 규모의 시스템에서는 언체크 예외를 쓰는 편이 유리할 것 같습니다.

3. 예외에 의미를 담아라

- 예외를 던질 때, 전후 맥락(오류가 발생한 원인·위치·관련 정보)을 메시지나 속성에 충분히 담아주면 디버깅과 유지보수에 큰 도움이 된다고 합니다.

4. 외부 라이브러리 예외를 감싸서(Wrapper) 단일 예외로 노출

- 외부 라이브러리가 다양한 예외를 던진다면, 이를 Wrapper 클래스를 통해 한두 개의 예외로 래핑해 호출부에 노출하면 좋다고 합니다.

```java
  public class LocalPort {
    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException | ATM1212UnlockedException | GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}
```

- 예로들어 LocalPort가 ACMEPort에서 던지는 여러 예외(DeviceResponseException | ATM1212UnlockedException | GMXError)에 대하여 하나의 예외를 던지게 되면 외부 API 의존성이 줄고, 테스트 및 유지보수가 쉬워지게 됩니다.
- 실제 로직에서 LocalPort만 쓰면 되므로, ACMEPort의 다양한 예외를 고려할 필요가 없게 됩니다.

5. 특수 사례 패턴(Special Case)으로 정상 흐름을 정의하라

- 예외 처리가 ‘정상 흐름’의 일부가 되면, 로직이 복잡해집니다
- 예로들어 식비가 없는 경우 예외를 던지기 보단 식비가 없더라도 “빈 객체”(PerDiemMealExpenses)를 반환하여, 클라이언트 코드가 “항상 식비 객체가 있다”고 가정하고 expenses.getTotal()만 호출하면 되게끔 만드는 것이 깔끔하다는 것을 보여주고 있습니다.
- 이렇게 되면 출부가 예외를 처리하지 않아도 되며, 코드의 분기(조건문, 예외처리)가 줄어들게 됩니다.

### 정리

저자는 “오류 처리는 프로그램에서 빠질 수 없지만, 오류 처리 로직이 핵심 로직과 섞이면 코드가 난해해진다”는 점을 일관되게 강조하고 있습니다.

예외를 적극적으로 사용하여 정상 흐름과 오류 흐름을 분리하고, 필요하다면 언체크 예외를 통해 캡슐화를 유지하며, 특수 사례 패턴·래퍼(Wrapper) 기법·빈 객체 반환을 통해 null과 중복된 예외 코드를 줄이는 방향이 이상적이라는 것을 코드 예시를 통해 보여주고 있습니다.

오류 처리를 독립적으로 하면서 오히려 깔끔하게 프로그램의 본연의 비즈니스 로직이 명확해지고 예외처리를 분리시키는 것의 예시를 확인해보니 앞으로 예외처리를 감싸거나 언체크 예외를 사용하는 방식으로 예외와 비즈니스 논리를 독립적으로 분리하여 관리해야 할 것 같습니다.
