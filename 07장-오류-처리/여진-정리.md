# Chapter 7. 오류 처리

<br>


## ⚠️ 1. 오류 처리 

- **오류 코드가 중요한 이유**
    - 프로그램은 언제든 실패할 수 있다.
    - 오류 발생 시 책임은 프로그래머에게 있다.
    - 오류 처리 코드가 흩어지면, 실제 코드의 목적이 흐려진다.
- **오류 처리 = 설계 요소**
    - 단순한 대응이 아니라, 논리 흐름과 분리된 관심사다.
    - 로직과 오류 처리를 분리해야 코드가 명확해진다.
    - 잘 설계된 오류 처리는 유지보수를 쉽게 만든다.

<br>

## ❗ 2. 오류 코드 vs 예외 

- **전통적인 오류 처리 방식**
    - 예외를 지원하지 않는 언어에서 흔히 사용됐다.
    - 오류가 발생하면 플래그를 설정하거나 오류 코드를 반환했다.
    - 호출자는 함수 실행 직후 오류 여부를 직접 확인해야 한다.
    - 로직과 오류 처리가 섞여 **코드가 복잡**해지고 **가독성이 떨어진다.**
- **예외 사용의 장점**
    - 오류 발생 시 예외를 던지면 코드 흐름이 명확해진다.
    - 호출자는 정상 흐름에 집중할 수 있다.
    - 예외 처리는 별도로 분리되어, 코드가 깔끔해진다.

<br>

## 🛠️ 3. 예외 처리의 실전 전략 

- **try-catch-finally부터 작성하라**
    - try 블록은 트랜잭션처럼 동작한다.
    - 중간에 예외가 발생해도 catch 블록이 **프로그램 상태를 일관되게 유지**해야 한다.
    - try 범위를 먼저 정의하면 **핵심 로직을 중심으로 예외를 설계**할 수 있다. (TDD)
- **미확인(unchecked) 예외를 사용하라**
    - 확인된 예외는 메서드 선언에 명시해야 하며,  
        → 호출하는 모든 곳에 **catch 처리나 throws 전파**가 필요하다.
    - 이는 OCP(개방-폐쇄 원칙) 위반이며, **코드 변경이 연쇄적으로 발생**한다.
    - 미확인 예외는 선언이 필요 없어 **유연한 구조 설계에 유리**하다.

<br>

## 📋 4. 예외 메시지 & 설계 기준 

- **예외에 의미를 담아라**
    - 실패한 **연산의 이름과 유형**을 예외 메시지에 포함하라.
    - 단순 호출 스택 외에도 **전후 맥락 정보를 함께 제공**해야 한다.
    - 예외 메시지는 **문제를 이해하고 디버깅할 수 있는 단서**가 되어야 한다.
- **호출자 중심으로 예외 클래스를 정의하라**
    - 대부분의 경우 예외 클래스는 **하나로도 충분**하다.
    - **예외 내부 정보**로 상황을 구분할 수 있으면 별도 클래스를 만들 필요는 없다.
    - 외부 라이브러리의 예외는 **감싸서 재정의**하면  
        → **의존성 완화** 및 **테스트 유연성 확보** 가능

<br>

## ⚙️ 5. 정상 흐름을 위한 전략 

- **특수 사례 패턴(Special Case Pattern)을 사용하라**
    - 예외 대신 **클래스나 객체로 예외 상황을 캡슐화**한다.
    - 클라이언트는 **예외 처리를 하지 않고도 정상 흐름처럼 동작**할 수 있다.
    - 조건 분기 없이, **객체 자체가 예외적인 상황을 내포**하도록 설계한다.
- **예외는 흐름 제어 용도로 쓰지 마라**
    - 예외는 **정말 예외적인 상황**에만 사용해야 한다.
    - 반복적이거나 예측 가능한 상황은 **객체나 조건 처리로 해결**하는 것이 좋다.

<br>

## 🚫 6. null 반환과 전달 피하기 

- **null을 반환하지 마라**
    - null을 반환하면 **호출자에게 책임을 전가**하게 된다.
    - 호출자가 null 확인을 빼먹는 순간 **예기치 않은 오류**가 발생할 수 있다.
    - null 대신 다음을 고려하라:
        - 예외 던지기
        - 특수 사례 객체 반환
        - Optional(지원하는 언어에서)
- **null을 전달하지 마라**
    - null을 인수로 기대하지 않는 메서드에 전달하면 **계약 위반**이 된다.
    - 대부분의 언어는 **실수로 전달된 null을 안전하게 처리하지 못한다.**
    - null 전달을 방지하기 위해
        - 사전 조건 검사
        - assert 또는 예외 처리 등을 활용한다.

<br>

## 결론 

- **오류 처리는 독립적인 관심사다**
    - 오류 처리는 **비즈니스 로직과 분리되어야 할 별도의 책임 영역**이다.
    - 분리함으로써 코드를 **명확하게 이해하고 독립적으로 추론**할 수 있다.
    - 로직과 오류 처리의 분리는 **유지보수성과 테스트 용이성**을 높인다.
- **오류 처리의 목표는 안정성과 가독성이다**
    - 잘 구조화된 오류 처리는 **코드의 안정성을 높이고,**  
        **독자가 빠르게 이해할 수 있도록 돕는다.**
    - **읽기 쉽고 신뢰할 수 있는 코드**를 만드는 데 필수적인 요소다.
