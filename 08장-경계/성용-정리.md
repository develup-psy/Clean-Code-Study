# 8장. 남이 만든 코드를 잘 사용하는 방법

## 1. 8장에 대한 핵심 내용

클린 코드 9장은 “소프트웨어 경계(특히 외부 라이브러리나 아직 정의되지 않은 코드와의 경계)를 어떻게 깔끔히 다룰 것인가”를 주제로 합니다.

실무에서 우리는 직접 개발한 코드만 다루지 않고, 외부 패키지, 오픈 소스 라이브러리, 아직 정의되지 않은 API 등을 함께 사용하게 되는데 우리가 만든 코드와 남이 만든 코드 사이에서의 경계를 어떻게 잘 관리하여 시스템의 복잡도와 의존성을 최소화하고 코드의 깨끗함과 유연성을 유지하는 방법을 다룬 챕터입니다.

## 2. 8장 세부 내용

### 1. 경계와 관련된 기본 개념

1. 경계란?

- 우리 코드와 외부 코드를 연결하는 지점이다.
  - 예: 라이브러리의 API, 오픈소스 패키지의 클래스, 아직 정의되지 않은 모듈
- 이 경계를 깔끔하게 처리하지 않으면, 외부 코드 변화가 우리 코드 전체에 영향을 미치고, 테스트나 유지보수가 어려워진다.

2. 외부 코드 사용 시의 딜레마

- 패키지 제공자들은 “더 많은 환경, 더 많은 기능”을 제공하려고 노력해 유연하고 복합적인 인터페이스를 만든다.
  - 왜? 범용성을 높여야 최대한 많은 사람들이 이용하면서 돈을 벌 수 있기 때문...ㅎ
- 그런데 우리는 대부분 구체적인 요구사항에 충실한 인터페이스를 원한다.
- 이러한 간극 때문에 Map, List와 같은 범위가 넓고 위험한 구조를 애플리케이션 곳곳에서 사용하게 되면서 코드를 오용하거나 변경 영향을 크게 받는 것을 저자는 문제삼고있다.

### 2. “Map” 예시로 본 경계 문제

```java
public class Sensors {
    private Map sensors = new HashMap();

    public Sensor getById(String id) {
        return (Sensor) sensors.get(id);
    }
}
```

문제점

- Map은 지나치게 많은 기능(clear, put, remove, etc.)을 제공한다.
- 특정 객체 유형만 Map에 저장해야 한다는 설계 규칙을 강제할 수 없다.
- 또한 Map의 반환 타입은 Object이기 때문에 형변환 오류가 가능하고 반환 타입을 변경하는 책임은 오로지 클라이언트에게 있다.

해결

- 경계를 감싸는 래퍼 클래스를 만들어 내부적으로는 Map을 사용하되 외부로는 Map의 복잡성을 노출하지 않는 것이다.
- 결과적으로 Map 인터페이스가 변경되어도 래퍼 클래스만 수정하면 전체 프로그램에 영향이 덜해진다.
- 클라이언트는 그저 래퍼 클래스의 메서드만 호출하면 되고 무분별하게 Map 객체를 전달하지 않아도 되게 된다.

정리

- 외부 API를 직접 노출하지 말고 필요한 기능을 캡슐화해서
- 우리 프로그램에서 사용할 최소 인터페이스만 제공하라!!

### 3. 경계를 테스트하고 익히자(학습 테스트)

**학습 테스트**

외부 코드를 사용할 때, 문서만 믿고 바로 프로젝트에 통합하지 말고, 먼저 간단한 테스트 케이스를 만들어 실험해보는 것이 학습 테스트의 핵심 아이디어이다.

절차

1.  간단한 테스트 케이스 작성

- 라이브러리나 API의 핵심 기능만 호출하는 최소 예제를 만든다.
- 예로들어 log4j로 "hello" 메세지를 콘솔에 찍는 것만을 위한 최소 기능만 구현해본다.
- 이 때 필요한 설정은 무엇이고 기능은 무엇인지에 대해선 문서를 읽어야 한다.

2. 실행 및 디버깅

- 애러가 나면 해결책을 찾고, 또 테스트해서 완성한다.
- 점진적으로 라이브러리에 대한 이해도를 높인다.

3. 외부 API를 감싸는 Wrapper 클래스를 작성한다.

- 학습 테스트를 통해 얻은 지식을 바탕으로, 최소한의 인터페이스를 설계해 “우리 코드 – 외부 라이브러리” 경계를 깔끔히 캡슐화한다.

### 4. 아직 존재하지 않는 코드 사용하기

때로는 우리가 개발해야 할 시스템에 필요한 하위 모듈이 아직 정의되지 않았거나 우리가 통제할 수 없는 환경일 수 있다.

이런 경우 그냥 하위 모듈에 대한 인터페이스만 정의해두고 실제 구현체는 Adapter로 대체한다.

```java
public interface Transmitter {
    void transmit(Frequency freq, InputStream data);
}
```

예로들어 위와 같이 어떤 무선통신 시스템에서 Transmitter 모듈이 필요한 경우에 아직 Transmitter가 구현되지 않았다면, 우리는 Transmitter 인터페이스만 정의해두고 CommunicationsController 같은 우리의 상위 로직은 Transmitter가 제대로 구현됐다고 가정하고 깔끔한 코드를 쓸 수 있다.

실제 Transmitter 구현이 나중에 등장하면, Adapter를 통해 그 구현체를 연결하면 된다.

남이 구현하기 전까지 기다릴 필요가 없고 동시에 작업이 가능하며 Adapter 패턴을 통해 변경 범위를 최소화할 수 있다

### 결론

1. 경계 인터페이스를 우리 코드 안에 노출하지 말자

- 외부 API 혹은 아직 정의되지 않은 모듈과 직접 주고받기보다는 Wrapper/Adapter/Facade를 두어
- 우리 코드가 요구하는 최소한의 기능만 노출하는 별도 클래스로 감싼다

2. 학습 테스트로 외부 라이브러리를 익히고 안정성 확보

- 적은 비용으로 라이브러리를 실험하고 문서화
- 새로운 버전이 나왔을 때 테스트로 호환성 확인 가능

3. 변경 비용을 최소화

- 외부 라이브러리나 아직 정의되지 않은 코드가 변경될 가능성을 고려해, 한곳(Wrapper/Adapter)에만 수정이 몰리도록 설계
- 대규모 재빌드·재배포 없이도 빠른 대응이 가능하다.

결국, 이번 챕터는 경계를 깔끔하게 다루는 핵심은 “외부(또는 미정) 코드를 그대로 끌어쓰지 말고, 우리의 영역에서 통제 가능한 형태로 감싸라.”라는 메시지로 요약할 수 있을 것 같습니다.

앞으로의 프로젝트에 있어 외부 api를 어떻게 사용해야 할지 고민하던 참인데 중요한 지침서가 될 것 같습니다.
