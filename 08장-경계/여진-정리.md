# Chapter 8. 경계

<br>


## 🌍 1. 경계란 무엇인가 

- **개념 정리**
    - **경계(Boundary) :** 우리 시스템과 **외부 시스템, 라이브러리, 컴포넌트** 사이의 연결 지점이다.
    - 대부분의 소프트웨어는 **패키지, 오픈소스, 사내 다른 팀의 코드**에 의존해 개발된다.
    - 이 외부 코드를 **우리 코드에 안전하고 깔끔하게 통합**하기 위해 경계를 명확하게 정의하고 다루는 전략이 필요하다.
- **경계가 필요한 이유**
    - 외부 코드는 **우리가 통제할 수 없다.**
        
        → 버전 변경, 인터페이스 변경 등 **예측 불가능한 변화**가 발생할 수 있음.
        
    - 외부 코드의 인터페이스는 **너무 광범위하거나 유연**해서 **의도하지 않은 오용, 의존성 증가, 유지보수 어려움**을 유발할 수 있다.
- **핵심 개념**
    - 외부 코드는 **직접 사용하지 않고 감싸야** 한다.
    - 내부 코드는 외부 구현이 아닌, **우리가 통제 가능한 경계 인터페이스에만 의존**해야 한다.
    - 경계를 깔끔하게 정의하면 코드의 **의존성을 줄이고, 변경에 유연하게 대응**할 수 있다.

<br>


## 🔒 2. 외부 코드 캡슐화 전략 

- **외부 코드의 문제점**
    - 외부 라이브러리(예: `Map`, `Logger` 등)는 **기능이 지나치게 많고 유연**하다.
        
        → 의도치 않은 사용으로 인해 **오용 위험**이 크다.
        
    - 직접 사용하면
        
        → 외부 구현 세부사항이 **우리 코드로 침투**해 들어오고
        
        → 외부 변경에 따라 **우리 코드까지 영향을 받는다.**
        
- **캡슐화 전략**
    
    **외부 코드는 직접 사용하지 않고 내부에서 감싸야 한다.**
    
    → 내부에서는 **우리 목적에 맞는 작은 API만 제공**해야 한다.
    
    - 방법 요약
        - 외부 API를 **래퍼 클래스**로 감싼다.
        - 내부 상태와 동작을 통제할 수 있도록 **접근을 제한**한다.
        - 불필요한 외부 기능은 **노출하지 않는다**
    - 예시
        
        ```java
        // 직접 사용
        Map<String, Sensor> sensors = new HashMap<>();
        Sensor s = sensors.get(sensorId);
        
        // 캡슐화 방식
        public class Sensors {
            private Map<String, Sensor> sensors = new HashMap<>();
        
            public Sensor getById(String id) {
                return sensors.get(id);
            }
        }
        ```
        
        - Map의 광범위한 기능을 **외부에 노출하지 않고**, 필요한 기능만 제한적으로 제공
        - 내부에서 Map이 제네릭을 추가하거나 구조가 바뀌어도 **외부 코드는 영향을 받지 않음**
- **효과**
    - 외부 변경에 대한 **영향 최소화**
    - **비즈니스 규칙 위반을 방지**할 수 있음
    - 코드가 **오용되기 어려워지고**, **이해하기 쉬워진다**

<br>


## 📚 3. 학습 테스트로 경계 익히기 

- **학습 테스트**
    - 외부 라이브러리나 API를 사용하기 전에 **간단한 테스트 코드를 작성하여 동작을 실험**해보는 것
    - 우리 코드에 통합하기 전에 **의도한 방식대로 잘 작동하는지 확인**할 수 있다.
    - 외부 API를 실제로 적용하기 전에 **사용법과 작동 방식을 익히는 것**에 집중한다.
    - 라이브러리 문서를 해석하기보다는 **코드를 작성해 직접 검증**한다.
    - **장점**
        - **비용이 들지 않는다** (테스트는 가볍고 빠르다)
        - 사용 목적에 맞는 **정확한 실험을 통해 이해도를 높인다**
        - 학습 테스트는 이후에도 **회귀 테스트처럼 재사용 가능하다**
        - 테스트 코드 자체가 **문서 역할**을 한다

<br>


## 🧩 4. 존재하지 않는 코드의 경계 다루기 

- 외부 시스템이나 라이브러리가 **아직 존재하지 않더라도**, 사용할 것을 **예상하고 미리 인터페이스를 정의**할 수 있다.
- 이렇게 하면 우리 시스템은 외부 코드가 생기기 전부터 **독립적으로 개발되고 테스트**될 수 있다.
- **설계 전략**
    1. **예상 인터페이스 정의**
        - 먼저 사용할 기능을 기준으로 **필요한 인터페이스를 정의**한다.
        - 외부 API가 실제로 만들어질 때까지는 **임시 구현체(더미, 스텁 등)**로 대체할 수 있다.
    2. **Adapter 패턴 적용**
        - 외부 API가 제공하는 형식과 우리가 정의한 인터페이스 사이를 **Adapter로 연결**한다.
        - 실제 외부 코드가 생기더라도 내부 코드에는 영향을 주지 않고 교체 가능하다.
- **장점**
    - 외부 구현에 의존하지 않고 **내부 로직을 먼저 개발**할 수 있다.
    - 코드의 목적과 구조가 **더 분명하게 표현**된다.
    - 외부와 내부의 결합을 **유연하게 관리**할 수 있다.

<br>


## 🎯 5. 깨끗한 경계를 위한 설계 원칙 

- 외부 라이브러리, 시스템, API는 **우리의 통제 밖에 있는 요소**다.
- 이러한 외부 요소가 우리 코드에 **직접 침투하지 않도록 경계를 설정**해야 한다.
- **깨끗한 경계**란, 외부 코드와 내부 코드가 **느슨하게 연결**되어 있으며  
    내부 코드가 외부 변경에 **최대한 영향을 받지 않도록 설계**된 구조를 말한다.

### **설계 원칙**

1. **외부 코드는 감싸라**
    - 외부 API(`Map`, `Logger`, 외부 서비스 등)는  
        **직접 사용하지 말고 래퍼 클래스나 경계 클래스로 감싼다.**
        
2. **작은 인터페이스만 노출하라**
    - 외부 라이브러리의 **광범위한 기능 전체를 노출하지 말고**,  
        → 우리 목적에 맞는 **작고 제한된 인터페이스만 제공**한다.
        
3. **테스트 가능성을 고려하라**
    - 학습 테스트나 유닛 테스트를 통해  
        외부 API의 사용법을 익히고 **정확하게 통제**할 수 있도록 한다.
        
4. **Adapter로 유연하게 연결하라**
    - 외부 API가 제공하는 방식과  
        우리가 원하는 방식 사이에 **중간 연결 계층(Adapter)**을 둔다.
        
    - 이를 통해 **외부 변경에도 내부 코드를 수정하지 않고 대응**할 수 있다
