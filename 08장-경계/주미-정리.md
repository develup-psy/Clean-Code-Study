## 8장. 경계

---
## 📍 REVIEW

나, 또는 우리 팀이 온전히 작성한 코드와, 외부에서 작성된 코드 사이에는 간극이 분명히 존재한다. 이 간극을 넘어서, 외부 코드를 내 코드에서 호출하는 부분을 “경계”라고 표현한다. 외부 패키지, 오픈 소스, 또는 사내 다른 팀에서 작성한 컴포넌트 등 경계 바깥의 외부에서 작성된 코드를 어떻게 깔끔히 통합할 수 있을지에 대한 이야기를 담은 챕터이다.

## 📍 경계 코드를 분리하라

### 🔍 외부 코드란?

외부 코드란 나 또는 우리 팀이 아닌 외부에서, 즉 경계 밖에서 작성된 이미 만들어진 코드이다. 온전히 나의 코드로만 이루어진 프로그램은 드물다. 실제 프로그램을 작성할 때에는 외부의 코드를 많이 활용하게 된다. 이런 경계를 깔끔하게 처리하는 것은 중요하다.

#### ☑️ 제공자와 사용자의 간극

외부 인터페이스를 제공하는 사람은, 최대한 많은 사람과 환경에서 실행될 수 있는 적용성이 높은 패키지와 프레임워크를 제공하는 것이 목표이다. 이에 반해 본은의 코드에 해당 인터페이스를 적용하려는 사용자는, 본인에게 특화된 부분이 잘 해결되도록 본인의 요구에 집중하는 인터페이스를 원한다.

이 둘 사이에는 간극이 있다. 제공자의 의도 하에 일반적인 모든 경우에 수에 대한 기능이 담긴 패키지/프레임워크는, 사용자의 프로그램에 불필요한 기능이 담겨있게 된다. 불필요한 기능이라는 건 의도하지 않은 기능을 의미하고, 이는 프로그램에 치명적인 오류를 만들 수 있다는 가능성을 남긴다. 이것이 외부 코드를 신중히 다루어야 하는 이유이다.

### 🔍 외부 코드 사용 가이드

#### ☑️ 경계 인터페이스의 캡슐화

외부코드의 대표적인 위험성은, 일반적인 상황을 가정해 제작된 외부API가 클라이언트에서 사용되지 않아야 하는 메소드까지 제공한 경우 발생한다. 우리의 프로그램에서 이루어지지 않아야 하는 프로세스를 유도하는 과정이기 때문이다. 이런 경우, 경계 밖에 위치한 ***외부 인터페이스를 내부에서 작성한 클래스 안에 숨겨 캡슐화***하는 것이 해결방법이 된다.

예를 들어, java.util.Map을 살펴보자. 이 클래스는 모든 내용을 지우는 clear()메소드, 특정 값을 지우는 remove() 메소드를 제공한다. 내부 코드에서 이 Map의 객체를 생성해 사용한다면, 이 객체의 값을 지우는 clear() 또는 remove() 메소드를 실행하는 권한은 모든 클라이언트에게 주어진다. 하지만 이 때, 클라이언트에게 해당 권한이 없어야 하는 프로세스를 가진다면, 클라이언트가 올바르게 사용하기를 바라는 수밖에 없다. 과연 이것이 잘 설계된 프로그램이라고 할 수 있을까?

이 경우에 해결책은 Map을 다른 클래스 내부로 숨기는 것이다. 아래 코드로 예를 들어보자.

```java
public class Sensors {
    private Map<String, Sensor> sensors = SensorsFactory().get();
    
    public Sensor getById(String id) {
        return sensors.get(id);
    }
    
    ...
}
```

이 경우, 클라이언트는 Map을 직접 사용하는 것이 아니라 Sensors라는 클래스의 객체로 접근하게 된다. 내부적으로 재정의한 로직인 getById 메서드만 호출할 수 있게 되며, 클라이언트가 조작 가능한 범위를 제한할 수 있는 것이다. 즉, 필요한 인터페이스만 제공하며, 내부의 설계 규칙과 비즈니스 규칙을 따르도록 강제하는 것이 가능하다.

#### ☑️ 무지한 경계에 대해

내부와 외부 사이 경계에서의 ‘외부’는, 내가 무지한 영역에 대한 분야이기도 하다. 현재의 지식 수준으로 이해하기 어려운 미지의 범위라서 바로 작업하기가 어려운 분야를 의미하기도 한다. 예를 들어, 송신 시스템에 대한 지식이 부족한 사람이 통신 시스템 SW 개발 중 ‘송신기 모듈’을 작업해야 하는 상황을 맞이하면, 송신기 모듈은 명확히 ‘외부’의 분야인 것이다. 해당 모듈이 돌아가는 방식에 대한 API를 받을 때까지 기다릴 수밖에 없다고 느껴진다.

이러한 ‘무지한’ 경계의 경우에는, 해당 API를 받기 전 아직 존재하지 않는 코드에 대해, 자체적으로 인터페이스를 정의하는 것이 새로운 해결방안이다. 구체적인 방식을 모르고서도 구현을 나중으로 미루고, 이미 정의된 필요 기능을 바탕으로 우선 인터페이스/클래스에 대한 구조를 미리 작성할 수 있다는 것이다.

예를 들어, 송신기 모듈로부터 필요한 기능이 “지정한 주파수를 이용해 이 스트림에서 들어오는 자료를 아날로그 신호로 전송”하는 것이라고 할 때, 미리 ~~가 필요한 인터페이스를 정의할 수 있다는 것이다. 그리고 정의된 인터페이스는 Adapter Pattern으로 API 사용을 캡슐화할 수 있다. 즉, 원하는 방식대로 주어진 외부 API를 활용할 수 있는 인터페이스를 만들 수 있다는 것이다.

#### ☑️ 외부 코드를 대하는 태도

일반적으로 외부코드를 사용할 때는, 외부 API 문서를 읽으며 사용법을 익힌 다음, 나의 프로그램에 이를 활용하는 코드를 작성하면서 라이브러리가 동작하는지를 확인한다. 이럴 경우, 예상대로 동작하지 않는 버그가 발생하면, 내부 코드에 의한 것인지 외부 코드에 의한 것인지 판단하고 디버깅하는 것이 어렵다. 사실은 최초에 외부 API의 ‘사용법을 익히는 것’도 어렵다.

따라서 저자는 외부 코드를 다른 태도로 대하는 것을 제안한다. 바로 내부 코드 작성을 시작하기보다, 간단한 테스트 케이스부터 작성하며 외부 코드를 익히는 것이다. 즉, 프로그램에서 사용하고자 하는 목적에 맞춰서 외부 API 호출하며, 내부 프로그램이라는 통제된 환경 하에 API가 어떻게 작동할 수 있는지를 확인하는 흐름이다. 이러한 테스트 과정이 “학습테스트”이다.

## 📍 학습테스트를 사용하라

### 🔍 학습테스트의 필요성

학습테스트란 위에 서술된 대로, 코드 구현을 우선하며 통합 과정을 디버깅하기보다 프로그램에서 사용하고자 하는 목적에 맞춰서 외부 API 호출하는 테스트를 우선 진행하는 것이다. 기본적으로는 외부 코드를 내부코드에 더 fit하게 사용할 수 있도록 도와주는 이점이 있다.

#### ☑️ 학습테스트의 이점

외부 API 전체에서 실제 필요한 기능만 골라서 사용하도록 유도하는 방식이기 때문에, 오히려 필요한 지식만 습득하며 외부와 내부의 경계에 대한 이해도를 높이도록 도와준다.

외부 코드의 변경사항에 대한 유지보수성이 뛰어나다. 외부 코드의 버전 변경은 통제 가능한 범위가 아니고, 변경에 대한 유지보수는 또 하나의 공수가 된다. 학습테스트를 실시한다면 패키지 업데이트 시, 테스트를 먼저 돌려보고 기존과 차이가 있는지 또는 예상대로 돌아가는지 검증할 수 있다. 새 버전과의 호환성을 바로 확인하며 새 코드로의 이전을 쉽게 해 유지보수성을 높이는 것이다.

#### ☑️ 학습테스트의 예시 : log4j

log4j는 로깅 기능을 구현하도록 도와주는 아파치의 패키지이다. 도서에 예시로 나와있기는 하나, 현재는 잘 활용되지 않고 과거에 주로 사용되던 패키지이므로, 코드에 대한 이해도 보다는 테스트가 어떻게 진행되는 지의 과정을 이해하기 위한 목적으로 참고하는 것이 좋겠다.

화면에 “hello”를 출력하는 최초의 1차 테스트 케이스가 아래와 같이 작성되었다고 하자.

```java
// 1차 테스트 케이스 : 화면에 "hello"를 출력 시도
@Test
public void testLogCreate() {
    Logger logger = Logger.getLogger("MyLogger");
    logger.info("hello");
}
```

1차 테스트 케이스 결과 “Appender”라는 것이 필요하다는 오류가 발생할 것이다. 사용자는 오류에서 제시한 메시지를 가이드 삼아 API 문서를 찾아보며 어떤 코드를 추가해야 하는지 가늠할 수 있다. 이 경우에서는, 문서를 찾아본다면 결과적으로 ConsoleAppender를 생성해 2차 테스트 케이스를 작성할 수 있을 것이다.

```java
@Test
public void testLogAddAppender() {
    Logger logger = Logger.getLogger("MyLogger");
    ConsoleAppender appender = new ConsoleAppender();
    logger.addAppender(appender);
    logger.info("hello");
}
```

2차 테스트 케이스 결과, Appender에 출력 스트림이 없음을 확인할 수 있다. 출력을 구현할 수 있는 방법을 문서 및 검색으로 찾아보면, 다음과 같은 3차 테스트 케이스를 작성할 수 있다.

```java
@Test
public void testLogAddAppender() {
    Logger logger = Logger.getLogger("MyLogger");
    logger.removeAllAppenders();
    logger.addAppender(new ConsoleAppender(
       new PatternLayout("%p %t %m%n"),
        ConsoleAppender.SYSTEM_OUT));
    logger.info("hello");
}
```

3차 테스트 케이스 결과, Hello라는 로그 메시지가 정상적으로 출력됨을 확인할 수 있다.

이번 테스트에서 나아가, 인수를 제거했을 때 테스트가 정상적으로 실행되는지, 생성한 객체는 어떤 상태여야 하는지 등의 검증을 거치며 추가적인 테스트를 시행하며 외부 코드와의 통합 과정을 진행할 수 있다.

여기서 알아야 하는 사실은 log4j를 어떻게 활용해야 하는가가 아닌, 학습테스트가 어떻게 진행되는지의 일련의 과정이다. 우선 최초의 테스트를 실행하고, 발생하는 오류를 가이드삼아 테스트를 고도화시킨다. 이 때, 테스트를 고도화하는 과정은 이미 사용된 클래스와 인수 등에 대한 정보를 기반으로 하므로, 전체 외부 API에 대한 이해도를 요구하지 않는다. 내부 코드에서 외부코드와 연결되는 부분만 한정하여 이해도를 넓혀가면 되는 것이다.