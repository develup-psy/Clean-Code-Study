# 9장. 테스트 코드, 실제 코드보다 중요하다

## 1. 9장에 대한 내용 정리

### TDD(Test-Driven Development) 법칙 3가지

TDD는 “테스트를 먼저 작성하고, 그 다음 실제 코드를 작성한다”는 핵심 흐름으로, 반드시 지켜야 할 3가지 법칙이 있습니다.

1. 실패하는 단위 테스트를 작성하기 전에는 실제 코드를 작성하지 않는다.

- 이러한 법칙은 무조건 테스트를 머저 쓰라는 관행을 지키기 위한 법칙이다.
- 테스트가 없는 상황에서 코드를 작성하면, 어떤 동작을 어떻게 검증해야 할지 모호해지기 때문에 우선 테스트할 상황부터 고민해보면서 코드 작성을 시작하는 것입니다.

2. 컴파일 오류는 없으면서, 실행이 실패하는 정도로만 단위 테스트를 작성한다.

- 테스트가 컴파일 단계가 아닌 실행 단계에서 실패하도록 만들어야 한다는 내용입니다.
- 실패가 명확히 드러나야, 향후 코드를 작성하거나 수정했을 때 실패가 성공으로 바뀌는 순간을 인지하기 쉬워진다고 합니다.

3. 현재 실행 중인 테스트를 통과할 정도로만 실제 코드를 작성한다.

- TDD의 핵심인 ‘필요 최소한의 코드만 작성’ 원칙을 지키는 규칙입니다.
- 지나치게 많은 기능을 미리 구현하면 오버엔지니어링과 불필요한 복잡도가 야기될 수 있습니다.

위 3가지 법칙을 충실히 따르면, 실제 코드와 테스트 코드는 거의 동시에(불과 몇 초 차이) 생기게 되고 이 과정이 반복되면, 매일 수십 개, 매달 수백 개, 매년 수천 개에 달하는 테스트 케이스가 누적되어 사실상 전체 코드를 덮는 테스트 슈트가 마련됩니다.

하지만 테스트 케이스가 엄청나게 증가하면서 테스트 코드 관리가 제대로 되지 않으면 테스트 자체가 개발의 걸림돌이 될 수도 있습니다.

### 깨끗한 테스트 코드 유지의 중요성

1. 테스트 코드가 지저분해질 때의 문제점

- 제 코드(프로덕션 코드)와 달리, “테스트 코드는 적당히 작성해도 괜찮다”며 품질 기준을 낮춰버리는 팀을 저자는 만났다고 합니다.
- 처음에는 빨리 진행되는 것 같지만, 점차 복잡도와 중복이 쌓여가면, 테스트 코드를 수정하는 데 오히려 더 많은 비용이 들기 시작하는 것을 확인했다고 합니다.
- 실제 코드가 진화할 때마다 테스트 케이스를 수정해야 하는데, 지저분한 테스트 코드는 변경 비용이 기하급수적으로 올라가기 때문입니다.
- 구체적으론 테스트가 깨지면, 어딜 어떻게 고쳐야 할지 복잡해지고, 실패하는 테스트가 무더기로 쏟아지고
- 점점 테스트가 짐덩이가 되고 개발자들이 차라리 테스트를 없애는 상황이 생기게 됩니다.
- 하지만 테스트가 없는 상태에선 자신이 수정한 코드가 안전한지를 확인할 방법이 없으므로 운에 맞기는 코드를 작성하게 되는 것입니다.
- 이렇게 결함율이 점점 올라가면서 개발자들은 코드를 변경하기 두려워지게 되고 결국 실제 코드 품질이 점차 하락하게 되는 상황이 발생한다고 합니다.

결론적으로, 테스트 코드는 지저분해도 괜찮다는 결정이 팀 전체 생산성을 해치고 코드 품질을 망가뜨리는 주된 원인임을 저자의 경험을 통해 말해주고 있습니다.

2. 테스트 코드의 가치

- 테스트 코드는 실제 코드 못지않게 중요합니다.
- 제대로 된 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고, 때로는 강화하기도 합니다.
- 테스트 슈트가 강력할수록, 변경과 리팩터링을 안심하고 할 수 있습니다.
- 테스트가 없는 코드에서 변경은 잠정적 버그 생성 행위와 다름없습니다.

### 깨끗한 테스트 코드를 만들기 위한 핵심 원칙

“테스트 코드도 실제 코드만큼 중요”하다는 전제 아래,
테스트 코드를 지속적으로 깨끗하게 유지하기 위해서는 가독성이 최우선 과제가 됩니다.

1. 가독성, 가독성, 가독성

- 첫째도 가독성, 둘째도 가독성, 셋째도 가독성입니다.
- 테스트 코드를 읽는 사람(동료 개발자, 혹은 미래의 나)이 무리 없이 이해할 수 있어야 의미가 있습니다.
- 테스트 코드에서 명료성, 단순성, 풍부한 표현력을 추구해야 합니다.
- 테스트의 의도가 무엇인지 명확히 드러나야 합니다.

- “이 테스트가 어떤 시나리오를 검증하느냐?”가 코드를 읽기만 해도 바로 파악되어야 합니다.
- BUILD-OPERATE-CHECK 패턴(행위 기반):
  - BUILD: 테스트 대상이 되는 객체나 자료를 만든다.
  - OPERATE: 해당 객체에 어떤 조작(메서드 호출 등)을 수행한다.
  - CHECK: 결과(반환값, 상태 변화 등)를 검증(assert)한다.
- 테스트 코드 내에서 도메인 개념이나 절차를 직관적으로 표현할 수 있는 유틸리티 혹은 테스트 전용 API를 만드는 것이 좋습니다.
- “테스트 언어” 수준의 추상화를 통해, 복잡한 API 호출(HTTP 요청, DB 쿼리 등)을 간단하게 래핑하면 테스트가 훨씬 직관적이 됩니다.

2. 불필요한 상세 코드 제거

- 테스트 코드는 본론만 드러내고, 잡다한 설정이나 로직은 숨기는 것이 이상적입니다.
- 복잡한 설정, 환경 구성, 리소스 로딩 등은 Helper, 유틸, 혹은 테스트 전용 빌더 클래스 등으로 추상화하여 간단히 호출만 하도록 합니다.
- 가장 중요한 것은 이 테스트가 무엇을 검증하려고 하는가?를 방해하는 잡음이 없아야 한다는 것입니다.

3. 도메인 특화 테스트 언어(DSL) 활용

- 흔히 사용하는 API 호출을 테스트 코드 위에서 유틸성 함수로 캡슐화 → 테스트 코드가 간결해지고 의도가 분명해 집니다.
- 처음부터 특별한 DSL을 설계하지 않아도 되며, 테스트 코드를 리팩터링하다 보면 자연스럽게 이와 같은 유틸/함수가 추출됩니다
- 실제 코드에서는 허용되지 않는 방식(예: 메모리 사용량 많은 로직 등)도 테스트 전용으로는 괜찮을 수 있습니다

4. 테스트 코드와 실제 코드의 “이중 표준”

- 실제 프로덕션 코드는 성능, 유지보수, 가용성 등의 엄격한 기준을 적용해야 하지만
- 테스트 코드는 표현력/가독성을 높이는 데 훨씬 많은 비중을 둘 수 있습니다
- 약간 비효율적인 방식이라도, 테스트 환경에서 문제없다면 괜찮습니다
- 단, 기본적인 청결(중복 제거, 함수 분리, 적절한 네이밍)은 동일하게 적용해야 합니다

5. 테스트 함수당 assert 하나?

- JUnit 등에서 하나의 테스트 함수에 하나의 assert 문만 쓰도록 권장하는 학파(?)가 있습니다.
- 장점: 테스트가 실패했을 때 무엇이 실패했는지가 명확해져 디버깅이 쉬움
- 단점: 경우에 따라선 테스트가 지나치게 잘게 쪼개질 수 있음
- 더 세부적인 원칙은 테스트 함수당 개념 하나 입니다.
  - 하나의 개념(시나리오)을 검증하기 위해 여러 개의 assert가 필요하다면,
  - 그것은 논리적으로 한 덩어리로 묶일 수 있는지 고민해봐야 합니다.
- 함수명을given*...\_when*..._then_...으로 적절히 짓는 등,
  - 개념 중심으로 테스트를 작성하면 assert 개수 자체에 얽매이지 않고도 충분히 깔끔한 테스트가 가능하다고 합니다.

### F.I.R.S.T

깨끗한 테스트 코드는 “F.I.R.S.T”라는 다섯 가지 규칙을 만족해야 합니다.

1. Fast(빠르게)

- 테스트는 빨라야 합니다.

- 속도가 느리면 자주 돌리기 어렵고, 자주 돌리지 않으면 초기 결함을 조기 발견하기 힘듭니다.

- TDD, CI/CD 파이프라인에서는 수십, 수백 개의 테스트가 짧은 시간 안에 돌아야 합니다.

2. Independent(독립적)

- 각 테스트는 서로 의존해선 안 됩니다.

- 순서에 의존하거나, 앞 테스트가 만든 결과를 이어받는 식은 위험합니다.

- 만약 순서가 바뀌어 실패하면 원인 진단이 극도로 어려워집니다.

3. Repeatable(반복 가능)

- 어떤 환경에서든 테스트가 반복적으로 동일한 결과를 내야 합니다.

- 특정 OS나 특정 머신에서만 돌아간다면, 환경이 맞지 않을 때는 테스트를 건너뛰게 되어 결함 발견이 늦어집니다.

4. Self-Validating(자체 검증)

- 테스트 결과는 참/거짓(pass/fail)로 명확히 드러나야 합니다.

- 로그 파일을 별도로 뒤져봐야 알 수 있다면, 그건 제대로 된 자동화 테스트가 아닙니다.

5. Timely(적시에 작성)

- 테스트 코드는 실제 코드를 작성하기 직전에, 혹은 동시에 작성해야 합니다.

- 실제 코드를 먼저 만들어 놓고 테스트를 나중에 붙이면, 테스트가 힘든 구조가 되어 있을 가능성이 높습니다(테스트가 곤란한 설계를 이미 해버렸을 수 있음).

### 결론

> 테스트 코드도 클린 코드가 되어야 한다.

- 테스트 코드는 프로젝트 전체의 건강 상태를 지키는 핵심 장치입니다.
- 테스트 코드가 없거나 너무 엉망이면, 개발자들은 “이 코드를 바꾸면 무엇이 깨질지”를 알 방법이 없어 두려움에 빠집니다.
- 반대로, 테스트 코드가 깔끔하고, TDD 법칙과 F.I.R.S.T 원칙을 준수한다면

  - 코드 변경/리팩터링 과정에서 생길 수 있는 모든 결함을 조기에 발견하고
  - 실제 코드가 오랫동안 정갈한 구조를 유지할 수 있게 도와줍니다

  결국, 테스트 코드는 실제 코드만큼이나 정성을 들여 깔끔하게 작성해야 합니다.

  - 도메인 로직을 의도가 드러나게 테스트하는 API나 DSL을 만들고
  - 복잡한 절차나 준비 코드는 최소화하며,
  - 명확하고 읽기 쉬운 함수명과 단계 구분(Arrange-Act-Assert 혹은 Build-Operate-Check)을 통해,

- 어떤 시나리오가 어떻게 검증되는지 한눈에 알 수 있도록 해야 합니다
