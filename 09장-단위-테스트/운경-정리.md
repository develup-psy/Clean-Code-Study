# 9장 - 단위 테스트

## TDD 법칙 세 가지

- 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않음
- 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성
- 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성

→ 먼저 실패하는 단위 테스트 코드를 작성하고 이를 통과하는 최소한의 로직만을 가지는 실제 코드를 작성

## 깨끗한 테스트 코드 유지하기

- 테스트 코드를 깔끔하게 유지하는 것은 유지보수적인 측면에서 매우 중요
- 테스트 코드의 품질은 시간이 지날 수록 실제 코드의 품질로 이어짐

### -테스트는 유연성, 유지보수성, 재사용성을 제공한다

- 코드에 유연성, 유지 보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트
    - 테스트 코드가 없다면 모든 변경이 잠정적인 버그 → 개발자는 변경을 주저하게 됨
- 실제 코드를 점검하는 자동화된 단위 테스트 suite는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠

## 깨끗한 테스트 코드

- 깨끗한 테스트 코드를 만들기 위해선 가독성이 매우 중요
    - 가독성은 실제 코드보다 테스트 코드에 더 중요

### -도메인에 특화된 테스트 언어

- 시스템 조작 API를 사용하는 대신 API 위에 함수와 유틸리티를 구현하여 테스트 코드를 작성 → 특수 API

### -이중 표준

- 테스트 코드는 실제 코드만큼 효율적일 필요는 없음
- StringBuilder를 이용하면 자원과 메모리을 효율적으로 사용하지만 가독성 측면에서 별로일 수 있음 → 테스트 코드에서는 String += 를 이용해도 전혀 문제 없음

## 테스트당 assert 하나

- assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠름 → 일반적으로는 옳음
- 그러나 경우에 따라서는 하나의 테스트에서 2가지 이상의 내용을 검증해야 하는 경우도 존재
    - ex) 출력이 XML이다, 특정 문자열을 포함한다 라는 assert문 2가지를 하나로 병합하는 것은 부자연스러움
    - 각기 다른 테스트로 나누어 처리하자니, 배보다 배꼽이 큰 상황
        - Template method 패턴 활용, given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두기
        - @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣기

### -테스트당 개념 하나

- 테스트 함수마다 한 개념만 테스트하라
- 독자적인 개념 3개를 한 함수에서 테스트 하는 나쁜 예시
    
    ```java
    /**
     * addMonth() 메서드를 테스트하는 장황한 코드
     */
    public void testAddMonths() {
      SerialDate d1 = SerialDate.createInstance(31, 5, 2004);
    
      SerialDate d2 = SerialDate.addMonths(1, d1); 
      assertEquals(30, d2.getDayOfMonth()); 
      assertEquals(6, d2.getMonth()); 
      assertEquals(2004, d2.getYYYY());
      
      SerialDate d3 = SerialDate.addMonths(2, d1); 
      assertEquals(31, d3.getDayOfMonth()); 
      assertEquals(7, d3.getMonth()); 
      assertEquals(2004, d3.getYYYY());
      
      SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); 
      assertEquals(30, d4.getDayOfMonth());
      assertEquals(7, d4.getMonth());
      assertEquals(2004, d4.getYYYY());
    }
    ```
    
    - .addMonth에 주어진 날짜가 30일로 끝나는 달의 마지막 날짜인지, 31일로 끝나는 달의 마지막 날짜이느냐에 따라 다르게 동작해야 하는 3가지 경우
    

## F.I.R.S.T

- Fast
    - 테스트는 빨라야 함, 느리면 자주 돌리지 못해 코드 품질에 악 영향
- Independent
    - 테스트는 서로 독립적이어야 함, 의존적이면 하나가 실패할 때 나머지도 잇달하 실패하므로 원인 진단이 어려워짐
    - 단위 테스트로 부분 부분 나눠서 특정 부분의 오류를 찾으려는 것인데, 단위 테스트간의 의존성이 있는 것은 그러한 의미를 크게 훼손시키는 것
- Repeatable
    - 테스트는 어떤 환경에서도 반복 가능해야 함
        - 실제 배포된 환경, QA 환경, 심지어는 네트워크가 없는 환경
- Self-Validating
    - 테스트는 bool 값으로 결과를 내야 한다. 성공 아니면 실패
- Timely
    - 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현 (TDD)
    - 테스트가 불가능하도록 실제 코드를 설계하는 것을 방지

## 정리

- 코드에 유연성, 유지 보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트
    - 테스트 코드가 없다면 모든 변경이 잠정적인 버그 → 개발자는 변경을 주저하게 됨
- 깨끗한 테스트 코드를 만들기 위해선 가독성이 매우 중요
    - 이를 위해서 테스트 하나당 assert문 하나, 개념 하나로 관리하자