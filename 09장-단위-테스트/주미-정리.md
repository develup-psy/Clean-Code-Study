# 9장. 단위 테스트

---

## 📍 REVIEW

현재의 개발자들은 모두 단위테스트의 중요성에 대해 인지하고 있다. 과거의 단위테스트는 프로그램이 ‘돌아간다’는 걸 확인하는 일회성 코드에 불과하며 단위 테스트 중요도에 대한 인식이 부족했다. 하지만 최근에는 단위테스트를 신경쓰자는 것을 넘어서 테스트를 우선으로 작성하는 TDD(테스트 주도 개발)이라는 개발 프로세스까지 나올 정도로 단위 테스트에 대해 중요하게 여기고 있다. 이번 장의 결론부터 말하자면, 테스트 코드는 실행 코드만큼 중요하다는 것이다. 실행 코드를 작성할 때 유의해야 하는 법칙을 동일하게 적용하며 깨끗한 테스트 코드를 작성할 수 있어야 한다.

## 📍 깨끗한 테스트 코드

### 🔍 테스트 코드의 중요성

#### ☑️ 테스트 코드란?

테스트코드란, 소프트웨어의 기능이 **의도대로 동작하는지를 자동으로 확인하는 코드이다. 그 중 특히 단위테스트는, SW 전체 단위가 아닌 가장 작은 단위의 테스트로, 특정 모듈에 대해 독립적으로 진행되는 테스트이다.**

#### ☑️ 테스트 코드의 영향도

실제 코드가 변화하면, 테스트 코드 역시 변해야 한다. 지저분한 코드를 계속해서 유지보수하는 것이 어려운 것과 같이, 지저분한 테스트 코드를 계속 해서 유지보수하는 것 역시 어렵기 때문이다. 따라서 나쁜 테스트 코드는 나쁜 실제 코드 만큼의 영향도를 가진다.

예를 들어보자. 테스트 코드가 지저분하면, 실제 코드를 작성하는 시간보다 테스트 케이스를 추가하는 시간이 더 오래 걸릴 것이다. 새로이 변화하는 실제 코드를 따라갈 만한 테스트 케이스를 유지 보수하는 비용 또한 상당할 것이다. 그렇다면 팀은 결국 테스트 코드를 폐기하게 되고, 테스트 코드의 폐기는 테스트가 돌아가는지 확인하는 과정의 누락을 뜻하기 때문에, 전체적인 SW의 결함율이 높아진다. 지저분한 테스트 코드는 테스트를 안 하는 것보다 더 나쁘다.

#### ☑️ 테스트 코드는 실제 코드의 버팀목

테스트 코드가 있다면 실제 코드가 변경된 후에도 시스템이 정상 동작하는지 빠르게 피드백 받을 수 있다. 테스트 코드로 인해 실제 코드는 유연성을 얻는 것이다. 테스트 케이스가 다양한 상황에 대한 검증을 해주기 때문에 잠정적인 버그에 대한 위험성이 낮아지고 코드 변경은 쉬워진다.

즉, 테스트코드는 유연성, 유지보수성, 재사용성을 제공하는 버팀목으로, 실제 코드 만큼의 중요도를 가진다.

### 🔍 깨끗한 테스트 코드 작성하기

#### ☑️ 작게 작성하라

테스트 코드가 실제 코드만큼 중요하므로, 실제 코드 설계 시 유의해야 하는 부분을 동일하게 고려하면 된다. 모든 것의 기본 원칙은 “작게”다. 테스트 코드 역시, 모든 작성 가이드는 “작게” 작성하는 것에서 시작한다.

#### ☑️ 하나의 테스트 함수에는 하나의 개념만 테스트

테스트 함수는 assert 문을 이용해, 실제 결과가 의도한 것과 같은지를 검증한다. 우선 목표로 해야 하는 것은 하나의  함수마다 assert를 단 하나만 사용하는 것이다. assert가 하나라면 결론이 하나기 때문에 코드를 이해하기 빠르고, 가장 중요하게는, “작다.”

assert 문 개수는 최대한 줄이도록 해야 한다. 하지만 때때로 여러 개의 assert가 필요한 경우가 있다. 이러한 경우에는 목표를 하나의 assert문보다는 하나의 한 개념만 테스트하도록 조정할 수 있다. 이것저것 잡다한 개념을 연속으로 테스트하는 함수를 피하면, 함수의 길이는 저절로 작아지게 된다.

## 📍 테스트 코드 작성 법칙

### 🔍 작성할 때의 규칙

#### ☑️ TDD : 테스트 주도 개발

TDD(Test Driven Development)는 실제 코드 작성 전에 단위 테스트부터 작성하는 SW 개발 프로세스다. 아주 작은 단위의 테스트를 통과하는 간단한 코드를 작성하는 아주 짧은 단위의 개발 사이클을 반복하는 패턴이다. 이런 TDD를 따르기 위한 세 가지 법칙을 소개하겠다.

1. 실패하는 단위 테스트가 작성될 때 실제 코드를 작성할 것
2. 실행은 실패되어도 컴파일을 실패하지 않을 정도로 단위테스트를 작성할 것
3. 실패하는 단위테스트를 통과할 정도로만 실제 코드를 작성할 것.

위 법칙을 보면, 테스트 작성 이후 코드 작성이 아주 많이 반복되어야 함을 알 수 있다. 아주 짧은 주기가 반복되는 것이다.

#### ☑️ F.I.R.S.T

깨끗한 테스트가 따르는 5가지 규칙으로, 각 규칙의 첫 글자를 따면 FIRST가 된다.

1. FAST

   테스트는 최대한 자주 돌아가야 하므로, 빠르게 스행될 수 있어야 한다.

2. INDEPENDENT

   테스트는 테스트 간에 의존도 없이 독립적으로 수행돼야 한다. 테스트 간에 의존성이 생기면, 앞선 테스트로 인해 뒤의 테스트가 실패하는 경우가 생긴다. 이런 경우, 실패의 원인을 찾기 힘들어지고 결함 발생 위험도가 높아진다.

3. REPEATABLE

   테스트는 어떤 환경에서도 반복 가능해야 한다. 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황, 즉, 실패의 원인으로 환경을 탓할 여지가 있으면 안된다.

4. SELF-VALIDATING

   테스트는 bool값으로, “성공 아니면 실패”의 명확한 결과를 내야 한다. 로그 파일에 접근하거나, 수작업으로 결과를 도출하지 말아야 한다.

5. TIMELY

   테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 즉, TDD를 따른다.


### 🔍 적용해야 하는 구조

#### ☑️ BUILD-OPERATION-CHECK 패턴

테스트 코드가 주로 갖는 구조이다. 먼저 테스트 자료를 만들고(BUILD), 테스트 자료를 조작하며(OPERATION), 조작한 결과가 올바른지 확인(CHECK)한다. 중구난방으로 테스트를 작성하기보다, 해당 패턴을 따르는 것을 권장한다. 깔끔하고 보다 테스트의 목적을 갖도록 하는 구조이다.

#### ☑️ 테스트 API 코드

테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 위해 사용자가 직접 구현한 API이다. 여러 증복되는 assert문을 한 번에 해결하는 등 보다 효율적인 방법을 고안해내고 리팩토링 하는 과정에서 작성된다.

이런 테스트 API 코드의 표준은 일반 코드 작성의 표준과는 상이하다. 예를 들어보자.

```java
// 변경 전 코드
@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {
    hw.setTemp(WAY_TOO_COLD); 
    controller.tic(); 
    assertTrue(hw.heaterState());   
    assertTrue(hw.blowerState()); 
    assertFalse(hw.coolerState()); 
    assertFalse(hw.hiTempAlarm());       
    assertTrue(hw.loTempAlarm());
}

// 변경 후 코드
@Test
public void turnOnLoTempAlarmAtThreshold() throws Exception {
    wayTooCold();
    assertEquals("HBchL", hw.getState()); 
}
```

위 코드가 대표적인 예시이다. 5개의 assert문에 대해서, equal여부를 각각의 char의 대문자 여부로 판단하도록 하는 새로운 메소드를 구현해낸 것이다. 이는 기존 코드 설계 법칙을 완전히 위반하지만, 테스트 코드에서는 괜찮다. 테스트 코드는 오로지 테스트환경에서 돌아가는 코드로, 테스트를 수행해내는 것이 목적이기 때문이다.