# Chapter 10. 클래스

<br>

# 🏗️ 1. 클래스의 구조와 정보 은닉 

### 1) 클래스 구성 원칙

- **클래스는 읽기 쉬운 구조**를 가져야 하며, **중요한 정보에서 덜 중요한 정보 순으로 배치**해야 한다.
    1. **정적 상수(static final)**
        - 클래스 수준에서 변하지 않는 값
        - ex: `public static final int MAX = 100;`
    2. **정적 변수(static)**
        - 인스턴스와 무관하게 클래스 전체에서 공유되는 변수
    3. **인스턴스 변수(멤버 필드)**
        - 객체 상태를 나타내는 변수
    4. **공개 함수(public method)**
        - 클래스 외부에서 사용할 수 있는 API
    5. **비공개 함수(private method)**
        - 클래스 내부에서만 사용하는 헬퍼 메서드
- 좋은 클래스는 **신문 기사처럼 읽힌다.**
    - 위에는 **핵심 정보**(공개 인터페이스)
    - 아래로 갈수록 **구현 세부사항**(비공개 로직)

### 2) 캡슐화와 정보 은닉 

- **캡슐화(encapsulation)**는 클래스 내부 구현을 외부로부터 감추는 것
- 내부 상태나 구현 로직에 **직접 접근하지 못하게 제한**해야 클래스는 더 **안정적이고 변경에 강한 구조**가 된다

| 항목 | 권장 접근 수준 | 이유 |
| --- | --- | --- |
| 인스턴스 변수 (상태) | `private` | 외부에서 직접 접근 불가. 내부 구현 자유도 확보 |
| 유틸리티 함수 | `private` | 재사용 목적이 아닌, 내부 흐름 보조용 |
| 클래스 외부 공개 대상 | `public` 메서드 | 명확한 API 역할만 수행 |

- 테스트 코드에서 내부 구현에 접근해야 할 필요가 있다면, 다음과 같은 **제한적 공개 방식**을 고려할 수 있음:

| 방식 | 접근 허용 대상 | 특징 |
| --- | --- | --- |
| `protected` | 하위 클래스 | **상속 구조 내에서만** 허용됨 |
| 패키지 접근 (접근제한자 없음) | 같은 패키지 내 클래스 | **테스트 코드가 같은 패키지에 있을 때만 접근 가능** |

---

# 🎯 2. 클래스의 책임과 응집도 

### 1) 클래스는 작아야 한다

- "클래스는 작아야 한다"는 말의 진짜 의미는  **적은 함수 수가 아니라, 적은 책임 수**를 뜻한다.
- 클래스가 **여러 책임을 동시에 가지면** 변경될 이유도 여러 가지가 생기고 유지보수가 어려워진다.

| 비교 요소 | 잘못된 기준 | 올바른 기준 |
| --- | --- | --- |
| 판단 기준 | 메서드/줄 수 | **책임의 수 (SRP)** |
| 목표 | 덩어리만 줄이기 | **변경 이유를 하나로 제한**하기 |

- 분리의 신호
    - 클래스가 다음과 같은 경우라면 **너무 많은 책임을 지고 있는 것**:
        - 메서드들이 서로 다른 기능 영역을 다룬다
        - 변경 요청 시, **여러 영역에 걸쳐 수정**이 필요하다
        - 클래스가 점점 커지고, 이름도 모호해진다 (`Util`, `Manager` 등)
- 해결 방법
    - 클래스의 책임을 파악하고, **역할별로 클래스를 분리**한다.
    - 각 클래스는 **하나의 역할**만 담당하고, **그 역할에 집중된 메서드와 데이터만 포함**하도록 구성한다.

### 2) 단일 책임 원칙(SRP) 

- **SRP :** 클래스는 오직 **하나의 책임**만 가져야 하며, 그 책임으로 인해 **변경되어야 할 이유도 하나만 존재**해야 한다.

| 항목 | 설명 |
| --- | --- |
| 하나의 책임 | 특정 기능 또는 역할에 대한 전적인 책임 |
| 여러 책임 | 다양한 이유로 자주 변경 → 코드 안정성 저하 |
| 변경 발생 시 | 다른 책임과 **엉켜 있는 코드까지 수정 위험** 발생 |

- 하나의 책임 = 하나의 변경 이유
- 여러 방향의 변경을 피하기 위한 설계 핵심

### 3) 응집도(Cohesion) 

- **응집도란** 클래스 내 구성 요소(함수와 변수)가 **얼마나 밀접하게 연관되어 있는지를 나타내는 척도**이다.
- 응집도가 높을수록 클래스는 **하나의 목적에 집중된 구성**을 갖는다.
- 분리의 신호
    - 함수들이 공유하는 인스턴스 변수가 거의 없음
    - 클래스 내 함수들이 **서로 다른 영역의 책임을 수행**
    
    → 이런 경우는 **클래스를 분리**해 응집도를 높이는 것이 바람직함

### 4) 작은 클래스의 장점

- **작고 집중된 클래스**는 시스템의 **유연성과 품질**을 높이는 핵심 단위이다.
- "클래스는 작을수록 좋다"는 말은 **책임이 명확하고, 변화에 유연하며, 읽고 쓰기 쉬운 구조**를 의미한다.
    - 이해, 테스트, 확장, 변경이 쉬운 구조
    - 소형화된 단위는 유연성과 품질의 기반
- 클래스가 작을수록 **수정할 부분이 명확하고 부담이 적다**
    - 한 기능만 수정하거나 교체할 수 있어 전체 시스템에 미치는 리스크가 줄어든다

---

# 🔄 3. 유연한 설계와 의존성 관리 

### 1) 변경에 강한 구조 (SRP + OCP) 

- **좋은 클래스 구조는 변경에 강하고, 확장에 유연해야 한다.**
    - 테스트 유연성 확보
    - 핵심 로직 보호
- 이를 위해 **SRP(단일 책임 원칙)**과 **OCP(개방-폐쇄 원칙)**을 함께 적용한다.

| 원칙 | 핵심 내용 |
| --- | --- |
| **SRP** | 클래스는 하나의 책임만 가져야 하며, 변경 이유도 하나여야 한다. |
| **OCP** | 기존 코드를 수정하지 않고도 기능을 확장할 수 있어야 한다. |

### 2) 결합도 낮추기 (DIP) 

- 클래스는 **구체 구현이 아닌 추상(인터페이스)**에 의존해야 한다.
- 외부 시스템(API, DB 등)에 **직접 의존하면 유연성과 테스트성 저하**
    
    → **DIP를 적용해 결합도를 낮춰야 한다.**

- DIP 원칙 정의

    > "상위 모듈이 하위 모듈에 의존해서는 안 된다.  
    양쪽 모두 추상(인터페이스)에 의존해야 한다."
    
    - **상위 모듈**: 비즈니스 로직 (ex: `Portfolio`)
    - **하위 모듈**: 외부 시스템 구현 (ex: `RealStockExchange`)
- 외부 시스템에 직접 의존하지 않기
- 인터페이스로 의존성 역전(DIP) 적용

---

# 🧑‍🏫 4. 클래스 설계 원칙 총정리 

- **좋은 클래스는 작고, 응집력 있으며, 변경과 확장에 강해야 한다.**
- 단순히 작기만 한 것이 아니라, **명확한 책임과 유연한 구조**를 가져야 한다.
- 핵심 원칙

| 원칙 | 핵심 내용 |
| --- | --- |
| **SRP (단일 책임 원칙)** | 클래스는 하나의 책임만 가지고, 하나의 변경 이유만 존재해야 한다 |
| **응집도 (Cohesion)** | 연관된 함수와 데이터를 함께 묶어, 클래스가 하나의 목적에 집중되도록 구성 |
| **캡슐화 (Encapsulation)** | 내부 상태와 구현 세부사항은 감추고, 명확한 외부 인터페이스만 공개 |
| **OCP (개방-폐쇄 원칙)** | 기존 코드를 변경하지 않고도 기능을 확장할 수 있도록 설계 |
| **DIP (의존성 역전 원칙)** | 구체 구현이 아닌 추상(인터페이스)에 의존하여 결합도 낮추기 |

- 좋은 클래스 구조의 조건

| 조건 | 설명 |
| --- | --- |
| 작고 명확한 책임 | 이해하기 쉽고 테스트하기 쉬움 |
| 응집도 높은 구성 | 관련 기능과 데이터가 잘 뭉쳐 있음 |
| 유연한 확장 가능성 | 요구 변화에 따른 대응이 쉬움 |
| 낮은 결합도 | 외부 영향 최소화, 유지보수 용이 |
| 테스트 용이성 | 구조가 깔끔해 테스트 코드 작성이 쉬움 |
