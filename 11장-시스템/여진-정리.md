# Chapter 11. 시스템

<br>

# 🏗️1. 설계 철학과 시스템 구조 

### 🌆1) 시스템은 도시처럼 구조화되어야 한다 

- 소프트웨어 시스템은 **도시(city)**에 비유할 수 있다.
    - 도시처럼 잘 구획되고 구조화된 시스템은 **확장성과 유지관리 용이성**을 갖춘다.
    - 도로, 건물, 규칙, 경계가 있듯 시스템도 **모듈, 계층, 인터페이스, 책임 분리**가 명확해야 한다.
- 시스템의 구조가 잘 잡혀 있으면:
    - 팀원 간 협업이 수월하고
    - 신규 개발자도 시스템의 흐름을 쉽게 파악할 수 있으며
    - 확장과 테스트, 리팩토링이 예측 가능한 방식으로 수행된다.
- 함수나 클래스 수준의 클린 코드만이 아니라,
    
    **전체 시스템 구조(설정, 계층, 의존성)까지도 깔끔하게 구성**되어야 진정한 의미의 클린 아키텍처가 된다.

### 2) 설계는 의사소통이다 🗣️

- **설계는 코드를 설명하는 도구이자, 팀 내 의사소통 수단**이다.
    - 코드와 구조는 사람에게 읽히기 위해 존재하며,
    - 시스템 설계는 팀원 간의 **공통된 이해를 돕는 설명 체계**가 되어야 한다.
- 설계가 명확하지 않으면:
    - 의도 전달이 어려워지고
    - 유지보수와 협업이 비효율적으로 흐르게 된다.
- 잘 설계된 시스템은 단지 동작하는 것이 아니라,
    
    **“왜 이렇게 동작하는가”를 구조를 통해 설명할 수 있어야 한다.**

---

<br>

# ⚙️2. 구성과 실행의 분리 원칙 

### 🔄1) 구성과 사용의 분리 

- 많은 코드에서 **객체 생성과 사용이 섞여 있는 구조**를 볼 수 있다.
    - 대표 예: `Lazy Initialization` 방식
        
        ```java
        if (scm == null)
            scm = new DefaultShippingCostCalculator();
        ```
        
- 이런 구조는 객체 생성 책임과 사용 책임이 뒤섞여 있어 **SRP(단일 책임 원칙)**을 위반한다.
- 결과적으로:
    - 코드가 복잡해지고
    - 테스트가 어려워지며
    - 변경 시 오류 가능성이 커진다.
- **해결책**: 객체의 생성 및 설정은 별도 구성 코드(setup)에서 처리하고,
    
    **애플리케이션 로직은 순수하게 사용에만 집중**하도록 분리해야 한다.

### 🎯2) Main 분리 패턴 

- `main()` 함수는 애플리케이션의 **진입점이자 조립자** 역할만 담당해야 한다.
- main에서는 필요한 객체들을 생성하고 연결한 후,
    
    애플리케이션을 실행만 한다.
    
    ```java
    public static void main(String[] args) {
        Controller controller = new Controller(new Service(new Repository()));
        controller.run();
    }
    ```
    
- 핵심 로직(Controller, Service 등)은 외부에서 객체가 주입되므로
    
    **main에 의존하지 않고 독립적으로 테스트 가능**하다.
    
- **의존성 흐름은 항상 main → 하위 구성 요소 방향으로 흘러야 한다.**
    - 구성은 위에서 아래로
    - 실행은 아래에서 위로

### 🏭3) 팩토리 & 추상 팩토리 

- **객체 생성 책임을 팩토리로 위임**하면,
    - 생성 방식이 변경되어도 사용하는 코드는 변경되지 않음.
- 클라이언트 코드는 팩토리 인터페이스만 의존하며,
    
    실제 생성 방식은 구체 팩토리에서 정의한다.
    
    ```java
    public interface ServiceFactory {
        Service create();
    }
    
    public class DefaultServiceFactory implements ServiceFactory {
        public Service create() {
            return new RealService();
        }
    }
    ```
    
- 이 방식은 다음과 같은 구조적 이점을 가진다:
    - **생성과 사용의 관심사 분리**
    - **테스트 환경/운영 환경에 따른 구현체 교체 가능**
    - **OCP(개방-폐쇄 원칙) 충실히 반영**

---

<br>

# 🔗3. 의존성과 유연한 설계 전략 

### 🧩1) 의존성 주입 (Dependency Injection) 

- **DI(Dependency Injection)**는 객체가 필요한 의존 객체를 **직접 생성하지 않고, 외부에서 주입받는 구조**를 말한다.
- DI는 **DIP(의존성 역전 원칙)** 실천의 대표적인 방식이며,
    
    테스트 가능성과 유연성을 높이는 핵심 전략이다.
    
- 주요 구현 방식
    
    | 방식       | 설명                             |
    | ---------- | -------------------------------- |
    | 생성자 주입 | 생성자에서 의존 객체를 받는다. 가장 안전하고 명시적 |
    | 세터 주입   | 세터 메서드를 통해 의존 객체를 주입 |
    | 인터페이스 주입 | 인터페이스를 통해 의존 객체를 전달 (전략 패턴과 결합 가능) |
- 장점 요약
    - 테스트 용이: Mock 객체나 Stub을 주입하여 단위 테스트 가능
    - 유연성 확보: 다양한 구현체 교체가 쉬움 (ex. 실서비스 ↔ 테스트용)
    - 결합도 감소: 구현체가 아닌 인터페이스에 의존하게 됨

### 📈2) 관심사의 분리와 구조의 진화 

- 시스템 설계는 **처음부터 완벽할 필요 없다.**
- 중요한 것은 처음부터 모든 것을 정하는 것이 아니라,
    
    **유연하게 진화 가능한 구조**를 마련하는 것이다.
    
- 관심사 분리의 예
    
    | 계층     | 역할                  |
    | -------- | --------------------- |
    | UI       | 사용자 인터페이스       |
    | 도메인 로직 | 핵심 비즈니스 로직       |
    | 인프라   | 데이터베이스, 프레임워크, API 등 외부 요소 |

    - 이렇게 관심사를 분리해두면, 특정 계층이 변경되어도 **다른 계층에 영향이 거의 없다.**
- 반례와 개선 사례
    
    | 항목   | 설명                                  |
    | ------ | ------------------------------------- |
    | EJB2   | 컨테이너에 강하게 결합, 테스트 어려움, 무거운 구조 |
    | EJB3, Spring | POJO 기반, 의존성 주입과 관심사 분리 실현, 테스트와 유지보수 용이 |

---

<br>

# 🔄4. 횡단 관심사와 아키텍처 품질 

### ⚙️1) 횡단 관심사와 AOP 

- **횡단 관심사(Cross-Cutting Concern)**란, 시스템 전반에 걸쳐 공통으로 나타나는 기능을 의미한다.
    - 예: 로깅, 트랜잭션, 보안, 예외 처리, 성능 측정 등
- 이러한 기능들이 여러 모듈에 퍼져 있으면 **중복 증가, 가독성 저하, 변경 어려움** 등의 문제가 생긴다.
- AOP(Aspect-Oriented Programming)의 역할
    - 횡단 관심사를 **핵심 로직과 분리하여 관리**할 수 있도록 도와주는 프로그래밍 패러다임
    - 주요 구현 방식:
        - JDK 동적 프록시
        - 스프링 AOP
        - AspectJ (바이트코드 위빙 방식)
    - 예시 전환
        
        ```java
        // 기존
        try {
            beginTransaction();
            doLogic();
            commit();
        } catch (Exception e) {
            rollback();
        }
        
        // AOP 적용
        @Transaction
        public void doLogic() {
            // 핵심 로직만 유지
        }
        ```

    - 효과
        - **핵심 로직의 순수성 유지**
        - **정책과 기능의 완전한 분리**
        - 변경에 강하고 유지보수성이 높은 구조 확보

### 🏋️2) POJO 기반 경량 구조 

- **POJO (Plain Old Java Object)**란 프레임워크에 종속되지 않은 순수한 자바 객체
- 과거의 무거운 구조(EJB2 등)는 컨테이너와 프레임워크에 강하게 결합돼 있어 테스트와 유지보수가 어려웠다.
- 경량 구조의 특징
    
    | 항목 | 설명 |
    | --- | --- |
    | 핵심 로직은 POJO로 구현 | 의존성 없음, 단순한 클래스 |
    | 부가 기능은 설정/주입으로 분리 | AOP, 트랜잭션, 보안 등은 외부 설정 |
    | 테스트와 유지보수 용이 | 독립 실행 및 Mock 주입 가능 |

- 스프링 예시 (XML 설정)
    
    ```xml
    <bean id="service" class="com.myapp.ServiceImpl">
        <property name="repository" ref="repo"/>
    </bean>
    ```
    
    - 핵심 서비스는 POJO로 작성되고, 트랜잭션이나 DI는 설정으로 처리됨

### 📜3) DSL (도메인 특화 언어) 

- **DSL(Domain-Specific Language)**는 특정 도메인에 맞춘 코드 표현 방식
- 핵심 개념: **코드가 도메인을 설명하는 언어가 되어야 한다**
- DSL의 역할과 예시
    - 도메인 전문가가 코드를 이해할 수 있는 수준의 **표현력과 가독성 제공**
    - 내부 DSL (메서드 체이닝, 유틸 함수 추상화)
    
    ```java
    order()
      .forCustomer("홍길동")
      .withItem("상품A", 2)
      .shipBy("퀵배송");
    ```
    
    - 테스트 DSL 예시
    
    ```java
    assertXmlContainsPages("PageOne", "PageTwo");
    ```
    
- 장점
    - 협업 용이성: 개발자 외에도 QA나 도메인 전문가가 이해 가능
    - 코드 목적이 명확하게 드러남
    - 유지보수 및 테스트가 쉬움

---

<br>

# 🏁5. 아키텍처의 결론과 실천 

### 단순함과 진화 가능성

- 아키텍처는 처음부터 완벽할 필요는 없다.
- **중요한 것은 단순하게 시작하고, 유연하게 진화할 수 있는 구조를 갖추는 것**이다.
- 관심사를 잘 분리하고 의존성을 통제하면, 시스템은 점진적으로 성장할 수 있다.

### 테스트 가능성이 구조 품질의 기준

- 테스트가 불가능하거나 어렵다면, 그 구조는 클린하지 않다.
- **의존성 주입, 인터페이스 분리, 계층 간 분리**는 테스트 가능성을 높이기 위한 전략이다.
- 테스트가 쉬운 구조는 곧 **이해하기 쉽고 유지보수가 쉬운 구조**다.

### 클린 코드 → 클린 아키텍처

- 함수와 클래스 수준의 클린 코드는 중요하지만,
**시스템 수준의 구조, 계층, 책임 분리까지 포함될 때 진정한 클린 아키텍처가 완성**된다.
- 잘 구성된 아키텍처는 다음을 가능하게 한다:
    - 변화에 강한 코드
    - 팀 간 명확한 역할 분담
    - 협업, 테스트, 확장에 강한 시스템
